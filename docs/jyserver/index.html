<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>jyserver API documentation</title>
    <meta name="description" content="Jyserver is a framework for simplifying the creation of font ends for apps and
kiosks by providing r..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#jyserver.JSCRIPT">JSCRIPT</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.Client">Client</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.Client.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.Client.h">h</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.ClientContext">ClientContext</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.ClientContext.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.addEndTask">addEndTask</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.addQuery">addQuery</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.addTask">addTask</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.callMethod">callMethod</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.delQuery">delQuery</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.get">get</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.getJS">getJS</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.getNextTask">getNextTask</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.getQuery">getQuery</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.hasMethod">hasMethod</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.htmlsend">htmlsend</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.log_error">log_error</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.log_message">log_message</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.mainRun">mainRun</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.mainRunThread">mainRunThread</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.processCommand">processCommand</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.render">render</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.render_django">render_django</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.run">run</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.run_callable">run_callable</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.set">set</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.showHome">showHome</a></li>
    <li class="mono"><a href="#jyserver.ClientContext.showPage">showPage</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.Handler">Handler</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.Handler.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.Handler.address_string">address_string</a></li>
    <li class="mono"><a href="#jyserver.Handler.copyfile">copyfile</a></li>
    <li class="mono"><a href="#jyserver.Handler.date_time_string">date_time_string</a></li>
    <li class="mono"><a href="#jyserver.Handler.do_GET">do_GET</a></li>
    <li class="mono"><a href="#jyserver.Handler.do_HEAD">do_HEAD</a></li>
    <li class="mono"><a href="#jyserver.Handler.do_PAGE">do_PAGE</a></li>
    <li class="mono"><a href="#jyserver.Handler.do_POST">do_POST</a></li>
    <li class="mono"><a href="#jyserver.Handler.end_headers">end_headers</a></li>
    <li class="mono"><a href="#jyserver.Handler.finish">finish</a></li>
    <li class="mono"><a href="#jyserver.Handler.flush_headers">flush_headers</a></li>
    <li class="mono"><a href="#jyserver.Handler.getContext">getContext</a></li>
    <li class="mono"><a href="#jyserver.Handler.guess_type">guess_type</a></li>
    <li class="mono"><a href="#jyserver.Handler.handle">handle</a></li>
    <li class="mono"><a href="#jyserver.Handler.handle_expect_100">handle_expect_100</a></li>
    <li class="mono"><a href="#jyserver.Handler.handle_one_request">handle_one_request</a></li>
    <li class="mono"><a href="#jyserver.Handler.list_directory">list_directory</a></li>
    <li class="mono"><a href="#jyserver.Handler.log_date_time_string">log_date_time_string</a></li>
    <li class="mono"><a href="#jyserver.Handler.log_error">log_error</a></li>
    <li class="mono"><a href="#jyserver.Handler.log_message">log_message</a></li>
    <li class="mono"><a href="#jyserver.Handler.log_request">log_request</a></li>
    <li class="mono"><a href="#jyserver.Handler.parse_request">parse_request</a></li>
    <li class="mono"><a href="#jyserver.Handler.processCookies">processCookies</a></li>
    <li class="mono"><a href="#jyserver.Handler.reply">reply</a></li>
    <li class="mono"><a href="#jyserver.Handler.replyFile">replyFile</a></li>
    <li class="mono"><a href="#jyserver.Handler.send_error">send_error</a></li>
    <li class="mono"><a href="#jyserver.Handler.send_head">send_head</a></li>
    <li class="mono"><a href="#jyserver.Handler.send_header">send_header</a></li>
    <li class="mono"><a href="#jyserver.Handler.send_response">send_response</a></li>
    <li class="mono"><a href="#jyserver.Handler.send_response_only">send_response_only</a></li>
    <li class="mono"><a href="#jyserver.Handler.setup">setup</a></li>
    <li class="mono"><a href="#jyserver.Handler.translate_path">translate_path</a></li>
    <li class="mono"><a href="#jyserver.Handler.version_string">version_string</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.HtmlPage">HtmlPage</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.HtmlPage.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.HtmlPage.alive">alive</a></li>
    <li class="mono"><a href="#jyserver.HtmlPage.html">html</a></li>
    <li class="mono"><a href="#jyserver.HtmlPage.insertJS">insertJS</a></li>
    <li class="mono"><a href="#jyserver.HtmlPage.expire">expire</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.JSchain">JSchain</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.JSchain.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.JSchain.eval">eval</a></li>
    <li class="mono"><a href="#jyserver.JSchain.evalAsync">evalAsync</a></li>
    <li class="mono"><a href="#jyserver.JSchain.execExpression">execExpression</a></li>
    <li class="mono"><a href="#jyserver.JSchain.getdata">getdata</a></li>
    <li class="mono"><a href="#jyserver.JSchain.setdata">setdata</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.JSroot">JSroot</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.JSroot.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.JSroot.call">call</a></li>
    <li class="mono"><a href="#jyserver.JSroot.eval">eval</a></li>
    <li class="mono"><a href="#jyserver.JSroot.val">val</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.Server">Server</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.Server.__init__">__init__</a></li>
    <li class="mono"><a href="#jyserver.Server.close_request">close_request</a></li>
    <li class="mono"><a href="#jyserver.Server.fileno">fileno</a></li>
    <li class="mono"><a href="#jyserver.Server.finish_request">finish_request</a></li>
    <li class="mono"><a href="#jyserver.Server.get_request">get_request</a></li>
    <li class="mono"><a href="#jyserver.Server.handle_error">handle_error</a></li>
    <li class="mono"><a href="#jyserver.Server.handle_request">handle_request</a></li>
    <li class="mono"><a href="#jyserver.Server.handle_timeout">handle_timeout</a></li>
    <li class="mono"><a href="#jyserver.Server.js">js</a></li>
    <li class="mono"><a href="#jyserver.Server.log_error">log_error</a></li>
    <li class="mono"><a href="#jyserver.Server.log_message">log_message</a></li>
    <li class="mono"><a href="#jyserver.Server.process_request">process_request</a></li>
    <li class="mono"><a href="#jyserver.Server.process_request_thread">process_request_thread</a></li>
    <li class="mono"><a href="#jyserver.Server.serve_forever">serve_forever</a></li>
    <li class="mono"><a href="#jyserver.Server.server_activate">server_activate</a></li>
    <li class="mono"><a href="#jyserver.Server.server_bind">server_bind</a></li>
    <li class="mono"><a href="#jyserver.Server.server_close">server_close</a></li>
    <li class="mono"><a href="#jyserver.Server.service_actions">service_actions</a></li>
    <li class="mono"><a href="#jyserver.Server.shutdown">shutdown</a></li>
    <li class="mono"><a href="#jyserver.Server.shutdown_request">shutdown_request</a></li>
    <li class="mono"><a href="#jyserver.Server.start">start</a></li>
    <li class="mono"><a href="#jyserver.Server.stop">stop</a></li>
    <li class="mono"><a href="#jyserver.Server.verify_request">verify_request</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#jyserver.XJSstate">XJSstate</a></span>
        
          
  <ul>
    <li class="mono"><a href="#jyserver.XJSstate.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">jyserver</span> module</h1>
  <p>Jyserver is a framework for simplifying the creation of font ends for apps and
kiosks by providing real-time access to the browser's DOM and Javascript from
the server using Python syntax. It also provides access to the Python code from
the browser's Javascript.</p>
<p>The difference between this framework and others (such as Django, Flask, etc.)
is that jyserver uses Python dynamic syntax evaluation so that you can write
Python code that will dynamically be converted to JS and executed on the
browser. On the browser end, it uses JS's dynamic Proxy object to rewrite JS
code for execution by the server. All of this is done transparently without any
additional libraries or code. See example below.</p>
<p>Documentation: <a href="https://ftrias.github.io/jyserver/">Class documentation</a></p>
<p>Tutorial: <a href="https://dev.to/ftrias/simple-kiosk-framework-in-python-2ane">Dev.to article</a></p>
<h2>Self-contained example:</h2>
<p>```
class App(Client):
    def <strong>init</strong>(self):
        self.html = """
        <p id="time">TIME</p>
        <button id="reset" onclick="server.reset()">Reset</button>
        """</p>
<pre><code>def reset(self):
    self.start0 = time.time()
    self.js.dom.time.innerHTML = "{:.1f}".format(0)

def main(self):
    self.start0 = time.time()
    while True:
        self.js.dom.time.innerHTML = "{:.1f}".format(time.time() - self.start0)
        time.sleep(0.1)
</code></pre>
<p>httpd = Server(App)
print("serving at port", httpd.port)
httpd.start()
```</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver', this);">Show source &equiv;</a></p>
  <div id="source-jyserver" class="source">
    <pre><code>'''
Jyserver is a framework for simplifying the creation of font ends for apps and
kiosks by providing real-time access to the browser's DOM and Javascript from
the server using Python syntax. It also provides access to the Python code from
the browser's Javascript.

The difference between this framework and others (such as Django, Flask, etc.)
is that jyserver uses Python dynamic syntax evaluation so that you can write
Python code that will dynamically be converted to JS and executed on the
browser. On the browser end, it uses JS's dynamic Proxy object to rewrite JS
code for execution by the server. All of this is done transparently without any
additional libraries or code. See example below.

Documentation: [Class documentation](https://ftrias.github.io/jyserver/)

Tutorial: [Dev.to article](https://dev.to/ftrias/simple-kiosk-framework-in-python-2ane)

Self-contained example:
-------------------------------
```
class App(Client):
    def __init__(self):
        self.html = """
        <p id="time">TIME</p>
        <button id="reset" onclick="server.reset()">Reset</button>
        """

    def reset(self):
        self.start0 = time.time()
        self.js.dom.time.innerHTML = "{:.1f}".format(0)

    def main(self):
        self.start0 = time.time()
        while True:
            self.js.dom.time.innerHTML = "{:.1f}".format(time.time() - self.start0)
            time.sleep(0.1)

httpd = Server(App)
print("serving at port", httpd.port)
httpd.start()
```
'''

from socketserver import ThreadingTCPServer
from http.server import SimpleHTTPRequestHandler
from http.cookies import SimpleCookie
from urllib.parse import urlparse, parse_qsl, unquote

from inspect import signature
import ctypes
import traceback

import json
import threading
import queue
import os
import copy
import re
import time
import uuid

#
# This is the Javascript code that gets injected into the HTML
# page.
#
# server            Proxy class for asynchronous execution of commands
#                   on the server. This class does not return a value.
#
# app               Proxy class that for synchronous exection. Will
#                   return a value. However, if used while a page
#                   update is in progress, it will fail.
#
# Other functions used internally:
#
# evalBrowser()     Queries the server for any pending commands. If
#                   there are no pending commands, the connection
#                   is kept open by the server until a pending
#                   command is issued, or a timeout. At the end of
#                   the query, the function gets scheduled for execution
#                   again. We schedule it instead of calling so we
#                   don't overflow the stack.
#
# sendFromBrowserToServer(e, q) 
#                   Evaluate expression `e` and then send the results
#                   to the server. This is used by the server to
#                   resolve Javascript statements.
#
# sendErrorToServer(e)
#                   Send a client expcetion to the server for error
#                   handling.
#
# closeBrowserWindow()
#                   Called when a page is terminated so server can
#                   stop processing it.
#
JSCRIPT = b"""
    if (typeof UID === "undefined") { UID = "COOKIE"; }
    if (typeof PAGEID === "undefined") { PAGEID = "COOKIE"; }
    function evalBrowser() {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (request.readyState==4 && request.status==200){
                setTimeout(evalBrowser, 1);
                try {
                    //console.log(request.responseText) // DEBUG
                    eval(request.responseText)
                }
                catch(e) {
                    //console.log("ERROR", e.message) // DEBUG
                    setTimeout(function(){sendErrorToServer(request.responseText, e.message);}, 1);
                    setTimeout(evalBrowser, 10);
                }
            }
        }
        request.open("POST", "/_process_srv0");
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session": PAGEID, "task":"next"}));
        //console.log("Query next commands") // DEBUG
    }
    function sendFromBrowserToServer(expression, query) {
        var value
        var error = ""
        try {
            //console.log(query, expression) // DEBUG
            value = eval(expression)
        }
        catch (e) {
            value = 0
            error = e.message + ": '" + expression + "'"
            console.log("ERROR", query, error)
        }
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0");
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session":PAGEID, "task":"state", "value":value, "query":query, "error": error}));
        //console.log("response",value) // DEBUG
    }
    function sendErrorToServer(expr, e) {
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0");
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify( {"session":PAGEID, "task":"error", "error":e, "expr":expr} ));
    }
    function closeBrowserWindow() {
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0");
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session":PAGEID, "task":"unload"}));
    }
    server = new Proxy({}, { 
        get : function(target, property) { 
            return function(...args) {
                var request = new XMLHttpRequest();
                request.onreadystatechange = function() {
                    if (request.readyState==4 && request.status==200){
                        result = JSON.parse(request.responseText)
                        if ("error" in result) {
                            console.log("ERROR async: ", property, request.responseText)
                            throw result["error"]
                        }
                    }
                }
                request.open("POST", "/_process_srv0");
                request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                request.send(JSON.stringify({"session":PAGEID, "task":"async", "function":property, "args":args}));
                //console.log("send asynch",property,args) // DEBUG
            }            
        }
    });
    function handleApp(property, args) { 
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0", false);
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session":PAGEID, "task":"run", "block":true, "function":property, "args":args}));
        if (request.status === 200) {
            var result = JSON.parse(request.responseText)
            if ("error" in result) {
                console.log("ERROR", result["error"]);
                throw result["error"];
                return null;
            }
            if (result["type"] == "expression") {
                return eval(result["expression"])
            }
            else {
                return result["value"]
            }
        }
    }
    function handleAppProperty(property) { 
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0", false);
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session":PAGEID, "task":"get", "block":true, "expression":property}));
        if (request.status === 200) {
            var result = JSON.parse(request.responseText)
            if ("error" in result) {
                console.log("ERROR", result["error"]);
                throw result["error"];
                return null;
            }
            if (result["type"] == "expression") {
                return eval(result["expression"])
            }
            else {
                return result["value"]
            }
        }
    }
    function handleAppSetProperty(property, value) { 
        var request = new XMLHttpRequest();
        request.open("POST", "/_process_srv0", false);
        request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        request.send(JSON.stringify({"session":PAGEID, "task":"set", "property":property, "value":value}));
        return value
    }
    app = new Proxy({}, { 
        get : function(target, prop) { 
            return handleAppProperty(prop)
        },
        set : function(target, prop, value) { 
            return handleAppSetProperty(prop, value)
        }
    });
    window.addEventListener("beforeunload", function(event) { closeBrowserWindow(); });
    window.addEventListener("load", function(event) { evalBrowser(); });
"""
    
class Client:
    '''
    Client class contains all methods and code that is executed on the server
    and browser. Users of this library should inherit this class and implement
    methods. There are three types of methods:

    Attributes
    ------------
    home
        Optional filename to send when "/" is requested
    html
        Optional HTML to send when "/" is requested. If neither
        `home` nor `html` are set, then it will send "index.html"
    js
        JS object for constructing and executing Javascript.

    Methods
    -----------

    h(file, html)
        Return appropriate HTML for the active page. Can only
        be called once per page. Must be called if implementing
        custom pages.
    
    Optional Methods
    ------------
    * main(self)

        If this is implemented, then the server will begin execution of this
        function immediately. The server will terminate when this function
        terminates.

    * index(self)

        If `index` is defined, it will execute this function. The function
        is responsible for returning the HTML with the h() method.

    * page(self)

        When the browser clicks on a link (or issues a GET) a method with the
        name of the page is executed. For example, clicking on link "http:/pg1"
        will cause a method named "pg1" to be executed.

    * func(self)

        When the browser executes a "server" command, the server runs a method
        with the same name. For example, if the browser runs the Javascript
        code:

            server.addnum(15, 65)

        then this method will be called:

            def func(self, 15, 65)
    '''
    def __init__(self):
        self.js = None
        self._state = None

    def h(self, html=None, file=None):
        '''
        Convert text to html and wrap with script code. Return the HTML as a
        byte string. Must be called if implementing a custom page
        such as `index`.
        '''
        return self._state.htmlsend(html, file)

class ClientContext:
    contextMap = {}
    taskTimeout = 5

    def __init__(self, cls, uid=None, verbose=False):
        self.appClass = cls
        self.obj = cls()
        self.queries = {}
        self.lock = threading.Lock()
        self.fxn = {}
        self.verbose = verbose
        self.tasks = queue.Queue()
        self.uid = uid
        self._error = None
        self._signal = None
        self.obj.js = JSroot(self)

    def render(self, html):
        # for Django support
        page = HtmlPage(html=html)
        html = page.html(self.uid)
        return html

    def render_django(self, inp):
        # for Django support
        page = HtmlPage(html=inp.content)
        inp.content = page.html(self.uid)
        return inp

    def htmlsend(self, html=None, file=None):
        page = HtmlPage(html=html, file=file)
        html = page.html(self.uid)
        self._handler.reply(html)
        self.log_message("SET SIGNAL %s", id(self._signal))
        self._signal.set()
        return page

    def hasMethod(self, name):
        return hasattr(self.obj, name)

    def callMethod(self, name, args=None):
        if hasattr(self.obj, name):
            f = getattr(self.obj, name)
            if args is None:
                f()
            else:
                f(*args)
        else:
            raise ValueError("Method not found: " + name)

    def __getattr__(self, attr):
        '''
        Unhandled calls to the context get routed to the app
        object.
        '''
        return self.obj.__getattribute__(attr)

    def getJS(self):
        return self.obj.js

    @classmethod
    def _getContextForPage(self, uid, appClass, create = False, verbose = False):
        '''
        Retrieve the Client instance for a given session id. If `create` is
        True, then if the app is not found a new one will be created. Otherwise
        if the app is not found, return None.
        '''
        if uid and not isinstance(uid, str):
            # if uid is a cookie, get it's value
            uid = uid.value

        # if we're not using cookies, direct links have uid of None
        if uid is None:
            # get first key
            if len(self.contextMap) > 0:
                uid = list(self.contextMap.items())[0][0]
            else:
                uid = None

        # existing app? return it
        if uid in self.contextMap:
            return self.contextMap[uid]
        else:
            # this is a new session or invalid session
            # assign it a new id
            # Instantiate Client, call initialize and save it.
            context = ClientContext(appClass, uid, verbose=verbose)
            self.contextMap[uid] = context
            context.log_message("NEW CONTEXT %s ID=%s", uid, id(self))
            # If there is a "main" function, then start a new thread to run it.
            # _mainRun will run main and terminate the server after main returns.
            context.mainRun()
            return context

        raise ValueError("Invalid or empty seession id: %s" % uid)

    def processCommand(self, req):
        pageid = req["session"]
        if pageid in HtmlPage.pageMap:
            self.uid = HtmlPage.pageMap[pageid]
        else:
            self.log_message("Invalid page id session %s", pageid)
            return 'Invalid pageid session: ' + pageid
            # raise RuntimeError("Invalid pageid session: " + pageid)

        HtmlPage.pageActive[pageid] = time.time()

        task = req["task"]
        self.log_message("RECEIVE TASK %s %s %s", task, self.uid, pageid)
        if task == "state":
            # The browser is replying to a request for data. First, find
            # the corresponding Queue for our request.
            q = self.getQuery(req['query'])
            # Add the results to the Queue, the code making the request is
            # currently waiting with a get(). This will cause that code
            # to wake up and process the results.
            q.put(req)
            # confirm to the server that we have processed this.
            return str(req)
        elif task == "run":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.run(req['function'], req['args'])
            return result
        elif task == "get":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.get(req['expression'])
            return result
        elif task == "set":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.set(req['property'], req['value'])
            return ''
        elif task == "async":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.run(req['function'], req['args'], block=False)
            return result
        elif task == "next":
            # the Browser is requesting we evaluate an expression and
            # return the results.
            script = self.getNextTask()
            self.log_message("NEXT TASK REQUESTED IS JS %s", script)
            return script
        elif task == "error":
            return ''
            # raise RuntimeError(req['error'] + ": " + req["expr"])
        elif task == "unload":
            self.addEndTask()
            HtmlPage.expire(pageid)
            # HtmlPage.raiseException(pageid, RuntimeError("unload"))
            self.log_message("UNLOAD %s", pageid)
            return ''

    def getQuery(self, query):
        '''
        Each query sent to the browser is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        return self.queries[query]

    def addQuery(self):
        '''
        Set query is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        q = queue.Queue()
        self.queries[id(q)] = q
        return id(q), q

    def delQuery(self, query):
        '''
        Delete query is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        return self.queries[query]

    def addTask(self, stmt):
        '''
        Add a task to the queue. If the queue is too long (5 in this case)
        the browser is too slow for the speed at which we are sending commands.
        In that case, wait for up to one second before sending the command.
        Perhaps the wait time and queue length should be configurable because they
        affect responsiveness.
        '''
        for _ in range(10):
            if self.tasks.qsize() < 5:
                self.tasks.put(stmt)
                self.log_message("ADD TASK %s ON %d", stmt, id(self.tasks))
                return
            time.sleep(0.1)
        self._error = TimeoutError("Timeout inserting task: " + stmt)


    def run(self, function, args, block=True):
        '''
        Called by the framework to execute a method. This function will look for a method
        with the given name. If it is found, it will execute it. If it is not found it
        will return a string saying so. If there is an error during execution it will
        return a string with the error message.
        '''
        self.log_message("RUN %s %s", function, args)
        if block:
            if not self.lock.acquire(blocking = False):
                raise RuntimeError("App is active and would block")
        
        try:
            if function == "_callfxn":
                # first argument is the function name
                # subsequent args are optional
                fxn = args.pop(0)
                f = self.fxn[fxn]
            elif callable(function):
                f = function
            elif hasattr(self.obj, function):
                f = getattr(self.obj, function)
            else:
                f = None

            if f:
                try:
                    result = f(*args)
                    ret = json.dumps({"value":JSroot._v(result)})
                except Exception as ex:
                    s = "%s: %s" % (type(ex).__name__, str(ex))
                    if self.verbose: traceback.print_exc()
                    self.log_message("Exception passed to browser: %s", s)
                    ret = json.dumps({"error":s})
            else:
                result = "Unsupported: " + function + "(" + str(args) + ")"
                ret = json.dumps({"error":str(result)})
            self.log_message("RUN RESULT %s", ret)
            return ret
        finally:
            if block:
                self.lock.release()

    def get(self, expr):
        '''
        Called by the framework to execute a method. This function will look for a method
        with the given name. If it is found, it will execute it. If it is not found it
        will return a string saying so. If there is an error during execution it will
        return a string with the error message.
        '''
        self.log_message("GET EXPR %s", expr)
        if not self.lock.acquire(blocking = False):
            raise RuntimeError("App is active and would block")
        
        try:
            if hasattr(self.obj, expr):
                value = getattr(self.obj, expr)
                if callable(value):
                    value = "(function(...args) { return handleApp('%s', args) })" % expr 
                    return json.dumps({"type":"expression", "expression":value})       
                else:
                    return json.dumps({"type":"value", "value":value})
            return None
        finally:
            self.lock.release()

    def set(self, expr, value):
        '''
        Called by the framework to set a propery.
        '''
        self.log_message("SET EXPR %s = %s", expr, value)
        self.obj.__setattr__(expr, value)
        return value

    def getNextTask(self):
        '''
        Wait for new tasks and return the next one. It will wait for 1 second and if
        there are no tasks return None.
        '''
        try:
            self.log_message("TASKS WAITING %d ON %d", self.tasks.qsize(), id(self.tasks))
            return self.tasks.get(timeout=self.taskTimeout)
        except queue.Empty:
            return None

    def addEndTask(self):
        '''
        Add a None task to end the queue.
        '''
        self.log_message("TASKS END %d ON %d", self.tasks.qsize(), id(self.tasks))
        self.tasks.put(None)

    def mainRun(self):
        if hasattr(self.obj, "main"):
            server_thread = threading.Thread(
                target=self.mainRunThread, daemon=True)
            server_thread.start()

    def mainRunThread(self):
        '''
        Run the main function. When the function ends, terminate the server.
        '''
        try:
            self.obj.main()
        except Exception as ex:
            self.log_message("FATAL ERROR: %s", ex)

    def showPage(self, handler, path, query):
        '''
        Called by framework to return a queried page. When the browser requests a web page
        (for example when a user clicks on a link), the path will get put in `path` and
        any paramters passed through GET or POST will get passed in `query`. This will
        look for a Client method with the same name as the page requested. If found, it will
        execute it and return the results. If not, it will return "not found", status 404.
        '''
        if callable(path):
            f = path
        else:
            fxn = path[1:].replace('/', '_').replace('.', '_')
            if hasattr(self.obj, fxn):
                f = getattr(self.obj, fxn)
            elif path == "/favicon.ico":
                handler.reply("Not found %s" % path, 404)
                return
            else:
                raise RuntimeWarning("Page not found: " + path)
                # return "Not found", 404

        self._handler = handler
        self._signal = threading.Event()
        self.log_message("START PAGE %s %d", path, id(self._signal))
        server_thread = threading.Thread(target=self.run_callable, 
                args=(f, {"page": path, "query": query}), daemon=True)
        server_thread.start()
        self.log_message("WAIT ON SIGNAL %s %d", path, id(self._signal))
        self._signal.wait() # set when HTML is sent
        self._signal = None

    def run_callable(self, f, args):
        params = signature(f).parameters
        try:
            if len(params) == 0:
                f()
            else:
                f(args)
        except Exception as ex:
            traceback.print_exc()
            self.log_message("Exception: %s" % str(ex))

    def showHome(self):
        '''
        Get the home page when "/" is queried and inject the appropriate javascript
        code. Returns a byte string suitable for replying back to the browser.
        '''
        if hasattr(self.obj, "html"):
            block = self.obj.html.encode("utf8")
            page = HtmlPage(block)
            self.activePage = page.pageid
            return page.html(self.uid)
        elif hasattr(self.obj, "home"):
            path = self.obj.home
        elif os.path.exists("index.html"):
            path = "index.html"
        elif hasattr(self.obj, "index"):
            return self.obj.index
        else:
            raise ValueError("Could not find index or home")

        with open(path, "rb") as f:
            block = f.read()
            page = HtmlPage(block)
            self.activePage = page.pageid
            return page.html(self.uid)

    def log_message(self, format, *args):
        if self.verbose:
            print(format % args)

    def log_error(self, format, *args):
        print(format % args)

class HtmlPage:
    # Patterns for matching HTML to figure out where to inject the javascript code
    _pscript = re.compile(
        b'\\<script.*\\s+src\\s*=\\s*"appscript.js"')
    _plist = [re.compile(b'\\{\\{JSCRIPT\\}\\}', re.IGNORECASE),
        re.compile(b'\\<script\\>', re.IGNORECASE),
        re.compile(b'\\<\\/head\\>', re.IGNORECASE),
        re.compile(b'\\<body\\>', re.IGNORECASE),
        re.compile(b'\\<html\\>', re.IGNORECASE)]

    pageMap = {}
    pageActive = {}
    # pageThread = {}
                       
    def __init__(self, html=None, file=None):
        if file:
            with open(file, "rb") as f:
                self.result = f.read()
        elif html:
            if isinstance(html, bytes):
                self.result = html
            else:
                self.result = html.encode("utf8")
        else:
            self.result = None
        self.pageid = uuid.uuid1().hex

    def alive(self):
        return self.pageid in self.pageActive

    @classmethod
    def expire(cls, item=None):
        if item:
            del cls.pageActive[item]
            del cls.pageMap[item]
            
        old = time.time() - 5
        remove = []
        for k,v in cls.pageActive.items():
            if v < old:
                remove.append(k)
        for k in remove:
            del cls.pageActive[k]
            del cls.pageMap[k]

    def html(self, uid):
        '''
        Once the page has been loaded, this will return the appropriate
        HTML for the uid given.
        '''
        return self.insertJS(uid, self.result)

    def insertJS(self, uid, html):
        '''
        Insert the Javascript library into HTML. The strategy is that it will look for patterns
        to figure out where to insert. If "<script src="appjscript.js">" is found, it will not
        make changes and will return the Javascript when the browser requests the appjscript.js
        file. Otherwise, it will insert it into a <script> section, the <head> or at the start
        of the HTML. In any case, this function will insert the global variable UID containing
        the session id.
        '''
        self.pageMap[self.pageid] = uid
        # self.pageThread[self.pageid] = threading.get_ident()
        self.pageActive[self.pageid] = time.time()

        U = "var UID='{}';var PAGEID='{}';\n".format(uid, self.pageid).encode("utf8")
        m = self._pscript.search(html)
        if m:
            sx, ex = m.span()
            return html[:sx] + b"<script>"+U+b"</script>" + html[sx:]
        for i, p in enumerate(self._plist):
            m = p.search(html)
            if m:
                sx, ex = m.span()
                if i == 0:
                    return html[:sx] + U + JSCRIPT + html[ex:]
                elif i == 1:
                    return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
                elif i == 2:
                    return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
                else:
                    return html[:sx] + b"<head><script>" + U + JSCRIPT + b"</script></head>" + html
        return b"<head><script>" + U + JSCRIPT + b"</script></head>" + html


class Server(ThreadingTCPServer):
    '''
    Server implements the web server, waits for connections and processes
    commands. Each browser request is handled in its own thread and so requests
    are asynchronous. The server starts listening when the "start()" method is
    called.

    Methods
    ------------
    start(wait, cookies)
    '''

    PORT = 8080
    allow_reuse_address = True

    def __init__(self, appClass, port=PORT, ip=None, verbose=False):
        '''
        Parameters
        -------------
        appClass
            Class that inherits Client. Note that this is the
            class name and not an instance.
        port
            Port to listen to (default is PORT)
        ip
            IP address to bind (default is all)
        '''
        self.verbose = verbose
        # Instantiate objects of this class; must inherit from Client
        self.appClass = appClass
        self.contextMap = {}
        # The port number
        self.port = port
        if ip is None:
            ip = '127.0.0.1'
        # Create the server object. Must call start() to begin listening.
        super(Server, self).__init__((ip, port), Handler)

    # def getContext(self):
    #     return self._getContextForPage('SINGLE')

    def js(self):
        '''
        If you are implementing a single application without a "main"
        function, you can call this to retrieve the JS object and set
        up for single instance execution.
        '''
        return self._getContextForPage('SINGLE', True).getJS()

    def _getContextForPage(self, uid, create = False):
        c = ClientContext._getContextForPage(uid, self.appClass, create=create, verbose=self.verbose)
        return c
        
    def stop(self):
        # self._BaseServer__shutdown_request = True
        self._runmode = False
        # self.shutdown()

    def _runServer(self):
        '''
        Begin running the server until terminated.
        '''
        self._runmode = True
        while self._runmode:
            self.handle_request()
        # self.serve_forever()
        self.log_message("SERVER TERMINATED")

    def start(self, wait=True, cookies=True):
        '''
        Start listening to the port and processing requests.

        Parameters
        ------------
        wait
            Start listening and wait for server to terminate. If this
            is false, start server on new thread and continue execution.
        cookies
            If True, try to use cookies to keep track of sessions. This
            enables the browser to open multiple windows that all share
            the same Client object. If False, then cookies are disabled
            and each tab will be it's own session.
        '''
        self.useCookies = cookies
        if wait or hasattr(self.appClass, "main"):
            self._runServer()
        else:
            server_thread = threading.Thread(target=self._runServer, daemon=True)
            server_thread.start()

    def log_message(self, format, *args):
        if self.verbose:
            print(format % args)
    def log_error(self, format, *args):
        print(format % args)

class Handler(SimpleHTTPRequestHandler):
    '''
    Handler is created for each request by the Server. This class
    handles the page requests and delegates tasks.
    '''

    def getContext(self):
        return self.server._getContextForPage(self.uid)

    def reply(self, data, num=200):
        '''
        Reply to the client with the given status code. If data is given as a string
        it will be encoded at utf8. Cookies are sent if they are used.
        '''
        self.send_response(num)
        if self.server.useCookies:
            self.send_header(
                "Set-Cookie", self.cookies.output(header='', sep=''))
        self.end_headers()

        if data is None:
            return

        if isinstance(data, str):
            data = data.encode("utf8")

        try:
            self.wfile.write(data)
            self.log_message("REPLY DONE")
        except Exception as ex:
            traceback.print_exc()
            self.server.log_error("Error sending: %s", str(ex))

    def replyFile(self, path, num=200):
        '''
        Reply to client with given file.
        '''
        with open(path, "rb") as f:
            block = f.read()
            result = HtmlPage(block).html(self.uid)
            self.reply(result)

    def processCookies(self):
        '''
        Read in cookies and extract the session id.
        '''
        if self.server.useCookies:
            self.cookies = SimpleCookie(self.headers.get('Cookie'))
            if "UID" in self.cookies:
                self.uid = self.cookies["UID"]
            else:
                self.uid = None

    def do_GET(self):
        '''
        Called by parent to process GET requests. Forwards requests to do_PAGE.
        '''
        if not self.server._runmode: return
        self.processCookies()
        qry = urlparse(self.path)
        req = dict(parse_qsl(qry.query))
        self.server.log_message("GET %s %s", qry, req)
        if "session" in req:
            pageid = req["session"]
            self.uid = HtmlPage.pageMap[pageid]
        else:
            self.uid = None
            # self.setNewUID()

        if qry.path == "/":
            # result = self.server._getHome(self.uid)
            c = self.getContext()
            result = c.showHome()
            if callable(result):
                self.log_message("HOME CALL %s", result)
                c.showPage(self, result, qry)
            else:
                self.log_message("HOME SEND %s", result)
                self.reply(result)
        elif qry.path == "/appscript.js":
            self.reply(JSCRIPT)
        else:
            self.do_PAGE(qry)

    def do_POST(self):
        '''
        Called by parent to process POST requests. Handles the built-in
        /state and /run requests and forwards all others to do_PAGE.
        '''
        if not self.server._runmode: return
        self.processCookies()
        l = int(self.headers["Content-length"])
        data = self.rfile.read(l)
        self.log_message("HTTP POST %s", data)
        if self.path == "/_process_srv0":
            self.log_message("PROCESS %s", data)
            req = json.loads(data)  
            c = self.getContext()
            results = c.processCommand(req)
            self.reply(results)
        else:
            self.do_PAGE(data)

    def do_PAGE(self, qry):
        '''
        Process page requests except /state and /run.
        '''
        self.log_message("PAGE %s", qry)
        if os.path.exists(qry.path[1:]):
            # try to send a file with the given name if it exists.
            self.replyFile(qry.path[1:])
        else:
            # otherwise, pass on the request to the Client object. It will
            # execute a method with the same name if it exists.
            c = self.getContext()
            c.showPage(self, qry.path, qry)

    def log_message(self, format, *args):
        if self.server.verbose:
            print(format % args)

class XJSstate:
    '''
    JState keeps track of the Javascript state on the browser.

    Attributes
    ------------
    _tasks
        A queue of pending tasks that must be performed on the
        browser.
    _fxn
        Map to keep track of callables that the browser's 
        Javascript is allowed to call.
    _queries
        When python requests a statement to be evaluated, a
        unique query id is assigned. Then a Queue is created
        to wait for reasults. This maps ids to Queues.
    _error
        If tasks have errors, the last Exception object is
        stored here. Value is None if there are no errors.
    _server
        The server tied to this state
    '''

    def __init__(self, server):
        self._tasks = queue.Queue()
        self._fxn = {}
        self._queries = {}
        self._error = None
        self._server = server
        self._lock = threading.Lock()

class JSchain:
    '''
    JSchain keeps track of the dynamically generated Javascript. It
    tracks names, data item accesses and function calls. JSchain
    is usually not used directly, but accessed through the JS class.

    Attributes
    -----------
    state
        A JSstate instance. This instance should be the same
        for all call of the same session.
        
    Notes
    -----------
    There is a special name called `dom` which is shorthand for
    lookups. For example,

        js.dom.button1.innerHTML

    Becomes

        js.document.getElementById("button1").innerHTML

    Example
    --------------
    ```
    state = JSstate(server)
    js = JSchain(state)
    js.document.getElementById("txt").value
    ```
    '''

    def __init__(self, state):
        self.state = state
        self.chain = []
        self.keep = True

    def _dup(self):
        '''
        Duplicate this chain for processing.
        '''
        js = JSchain(self.state)
        js.chain = self.chain.copy()  # [x[:] for x in self.chain]
        return js

    def _add(self, attr, dot=True):
        '''
        Add item to the chain. If `dot` is True, then a dot is added. If
        not, this is probably a function call and not dot should be added.
        '''
        if not attr:
            # this happens when __setattr__ is called when the first
            # item of a JSchain is an assignment
            return self
        if dot and len(self.chain) > 0:
            self.chain.append(".")
        self.chain.append(attr)
        return self

    def _prepend(self, attr):
        '''
        Add item to the start of the chain. 
        '''
        self.chain.insert(0, attr)
        return self

    def _last(self):
        '''
        Last item on the chain.
        '''
        return self.chain[-1]

    def __getattr__(self, attr):
        '''
        Called to process items in a dot chain in Python syntax. For example,
        in a.b.c, this will get called for "b" and "c".
        '''
        # __iter__ calls should be ignored
        if attr == "__iter__":
            return self
        return self.getdata(attr)

    def getdata(self, attr, adot=True):
        if self._last() == 'dom':
            # substitute the `dom` shortcut
            self.chain[-1] = 'document'
            self._add('getElementById')
            self._add('("{}")'.format(attr), dot=False)
        else:
            # add the item to the chain
            self._add(attr, dot=adot)
        return self

    def __setattr__(self, attr, value):
        value = JSroot._v(value)
        if attr == "chain" or attr == "state" or attr == "keep":
            # ignore our own attributes. If an attribute is added to "self" it
            # should be added here. I suppose this could be evaluated dynamically
            # using the __dict__ member.
            super(JSchain, self).__setattr__(attr, value)
            return value
        # print("SET", attr, value)
        self.setdata(attr, value)
        self.execExpression()

    def setdata(self, attr, value, adot=True):
        '''
        Called during assigment, as in `self.js.x = 10` or during a call
        assignement as in `self.js.onclick = func`, where func is a function.
        '''
        if callable(value):
            # is this a function call?
            idx = id(value)
            self.state.fxn[idx] = value
            self._add(attr, dot=adot)
            self._add("=function(){{server._callfxn(%s);}}" % idx, dot=False)
        else:
            # otherwise, regular assignment
            self._add(attr, dot=adot)
            self._add("=" + json.dumps(value), dot=False)
        return value

    def __setitem__(self, key, value):
        jkey = "['%s']" % str(key)
        self.setdata(jkey, value, adot=False)
        self.execExpression()
        return value

    def __getitem__(self, key):
        # all keys are strings in json, so format it
        key = str(key)
        c = self._dup()
        c._prepend("'%s' in " % key)
        haskey = c.eval()
        if not haskey:
            raise KeyError(key)
        jkey = "['%s']" % key
        c = self.getdata(jkey, adot=False)
        return c.eval()

    def __call__(self, *args, **kwargs):
        '''
        Called when we are using in a functiion context, as in
        `self.js.func(15)`.
        '''
        # evaluate the arguments
        p1 = [json.dumps(JSroot._v(v)) for v in args]
        p2 = [json.dumps(JSroot._v(v)) for k, v in kwargs.items()]
        s = ','.join(p1 + p2)
        # create the function call
        self._add('('+s+')', dot=False)
        return self

    def _statement(self):
        '''
        Join all the elements and return a string representation of the
        Javascript expression.
        '''
        return ''.join(self.chain)

    def __bytes__(self):
        '''
        Join the elements and return as bytes encode in utf8 suitable for
        sending back to the browser.
        '''
        return (''.join(self.chain)).encode("utf8")

    def evalAsync(self):
        if self.keep:
            stmt = self._statement()
            self.state.addTask(stmt)
            # mark it as evaluated
            self.keep = False

    def __del__(self):
        '''
        Execute the statment when the object is deleted.

        An object is deleted when it goes out of scope. That's when it is put
        together and sent to the browser for execution. 

        For statements,
        this happens when the statement ends. For example,

           self.js.func(1)

        goes out of scope when the statement after func(1). However,

           v = self.js.myvalue

        goes out of scope when the "v" goes out of scope, usually at then end of
        the function where it was used. In this case, the Javascript will be
        evaluated when "v" itself is evaluated. This happens when you perform
        an operation such as "v+5", saving or printing.

        "v" in the example above is assigned an object and not a value. This
        means that every time it is evaluated in an expression, it goes back 
        to the server and retrieves the current value.

        On the other hand,

           self.v = self.js.myvalue

        will probably never go out of scope because it is tied to the class.
        To force an evaluation, call the "eval()"
        method, as in "self.js.myvalue.eval()".
        '''
        if not self.keep: return
        # print("!!!DEL!!!")
        try:
            self.execExpression()
        except Exception as ex:
            self.state._error = ex
            self.state._server.log_error("Uncatchable exception: %s", str(ex))
            raise ex

    def execExpression(self):
        # Is this a temporary expression that cannot evaluated?
        if self.keep:
            stmt = self._statement()
            # print("EXEC", stmt)
            if self.state.lock.locked():
                # print("ASYNC", stmt)
                # running within a query, so just run it async
                self._addTask(stmt)
            else:
                # otherwise, wait for evaluation
                # print("SYNC", stmt)
                try:
                    self.eval()
                except Exception as ex:
                    self.keep = False
                    raise ex
            # mark it as evaluated
            self.keep = False

    def eval(self, timeout=10):
        '''
        Evaluate this object by converting it to Javascript, sending it to the browser
        and waiting for a response. This function is automatically called when the object
        is used in operators or goes out of scope so it rarely needs to
        be called directly.

        However, it is helpful
        to occasionally call this to avoid out-of-order results. For example,

            v = self.js.var1
            self.js.var1 = 10
            print(v)

        This will print the value 10, regardless of what var1 was before the assignment.
        That is because "v" is the abstract statemnt, not the evaluated value. 
        The assigment "var1=10" is evaluated immediately. However,
        "v" is evaluated by the Browser 
        when "v" is converted to a string in the print statement. If this is a problem,
        the code should be changed to:

            v = self.js.var1.eval()
            self.js.var1 = 10
            print(v)

        In that case, "v" is resolved immediately and hold the value of var1 before the
        assignment.

        Attributes
        -------------
        timeout
            Time to wait in seconds before giving up if no response is received.
        '''
        if not self.keep:
            return 0
            # raise ValueError("Expression cannot be evaluated")
        else:
            self.keep = False

        stmt = self._statement()
        # print("EVAL", stmt)

        c = self.state

        if c.lock.locked():
            c.log_error("App is active so you cannot manipulate JS for: %s" % stmt)
            raise RuntimeError("App is active so you cannot manipulate JS for: %s" % stmt)

        idx, q = c.addQuery()
        data = json.dumps(stmt)
        cmd = "sendFromBrowserToServer({}, {})".format(data, idx)
        c.addTask(cmd)
        try:
            c.log_message("WAITING ON RESULT QUEUE")
            result = q.get(timeout=timeout)
            c.delQuery(idx)
        except queue.Empty:
            # self.state._server.log_message("TIMEOUT waiting on: %s", stmt)
            raise TimeoutError("Timout waiting on: %s" % stmt)
        if result["error"] != "":
            # self.state._server.log_error("ERROR EVAL %s : %s", result["error"], stmt)
            raise RuntimeError(result["error"] + ": " + stmt)
        if "value" in result:
            return result["value"]
        else:
            return 0

    #
    # Magic methods. We create these methods for force the
    # Javascript to be evaluated if it is used in any
    # opreation.
    #
    def __cmp__(self, other): return self.eval().__cmp__(other)
    def __eq__(self, other): return self.eval().__eq__(other)
    def __ne__(self, other): return self.eval().__ne__(other)
    def __gt__(self, other): return self.eval().__gt__(other)
    def __lt__(self, other): return self.eval().__lt__(other)
    def __ge__(self, other): return self.eval().__ge__(other)
    def __le__(self, other): return self.eval().__le__(other)

    def __pos__(self): return self.eval().__pos__()
    def __neg__(self): return self.eval().__neg__()
    def __abs__(self): return self.eval().__abs__()
    def __invert__(self): return self.eval().__invert__()
    def __round__(self, n): return self.eval().__round__(n)
    def __floor__(self): return self.eval().__floor__()
    def __ceil__(self): return self.eval().__ceil__()
    def __trunc__(self): return self.eval().__trunc__()

    def __add__(self, other): return self.eval().__add__(other)
    def __and__(self, other): return self.eval().__and__(other)
    def __div__(self, other): return self.eval().__div__(other)
    def __divmod__(self, other): return self.eval().__divmod__(other)
    def __floordiv__(self, other): return self.eval().__floordiv__(other)
    def __lshift__(self, other): return self.eval().__lshift__(other)
    def __mod__(self, other): return self.eval().__mod__(other)
    def __mul__(self, other): return self.eval().__mul__(other)
    def __or__(self, other): return self.eval().__or__(other)
    def __pow__(self, other): return self.eval().__pow__(other)
    def __rshift__(self, other): return self.eval().__rshift__(other)
    def __sub__(self, other): return self.eval().__sub__(other)
    def __truediv__(self, other): return self.eval().__truediv__(other)
    def __xor__(self, other): return self.eval().__xor__(other)

    def __radd__(self, other): return self.eval().__radd__(other)
    def __rand__(self, other): return self.eval().__rand__(other)
    def __rdiv__(self, other): return self.eval().__rdiv__(other)
    def __rdivmod__(self, other): return self.eval().__rdivmod__(other)
    def __rfloordiv__(self, other): return self.eval().__rfloordiv__(other)
    def __rlshift__(self, other): return self.eval().__rlshift__(other)
    def __rmod__(self, other): return self.eval().__rmod__(other)
    def __rmul__(self, other): return self.eval().__rmul__(other)
    def __ror__(self, other): return self.eval().__ror__(other)
    def __rpow__(self, other): return self.eval().__rpow__(other)
    def __rrshift__(self, other): return self.eval().__rrshift__(other)
    def __rsub__(self, other): return self.eval().__rsub__(other)
    def __rtruediv__(self, other): return self.eval().__rtruediv__(other)
    def __rxor__(self, other): return self.eval().__rxor__(other)

    def __coerce__(self, other): return self.eval().__coerce__(other)
    def __complex__(self): return self.eval().__complex__()
    def __float__(self): return self.eval().__float__()
    def __hex__(self): return self.eval().__hex__()
    def __index__(self): return self.eval().__index__()
    def __int__(self): return self.eval().__int__()
    def __long__(self): return self.eval().__long__()
    def __oct__(self): return self.eval().__oct__()
    def __str__(self): return self.eval().__str__()
    def __dir__(self): return self.eval().__dir__()
    def __format__(self, formatstr): return self.eval().__format__(formatstr)
    def __hash__(self): return self.eval().__hash__()
    def __nonzero__(self): return self.eval().__nonzero__()
    def __repr__(self): return self.eval().__repr__()
    def __sizeof__(self): return self.eval().__sizeof__()
    def __unicode__(self): return self.eval().__unicode__()

    def __iter__(self): return self.eval().__iter__()
    def __reversed__(self): return self.eval().__reversed__()
    def __contains__(self, item): 
        d = self.eval()
        if isinstance(d, dict):
            # json makes all keys strings
            return d.__contains__(str(item))
        else:
            return d.__contains__(item)
    # def __missing__(self, key): return self.eval().__missing__(key)


class JSroot:
    '''
    JS handles the lifespan of JSchain objects and things like setting
    and evaluation on the root object.

    Example:
    --------------
    ```
    state = ClientContext(AppClass)
    js = JSroot(state)
    js.document.getElementById("txt").value = 25
    ```
    '''

    def __init__(self, state):
        # state is a JSstate instance unique for each session
        self.state = state
        # keep track of assignments
        self.linkset = {}
        # keep track of calls
        self.linkcall = {}

    @staticmethod
    def _v(value):
        '''
        If `value` is a JSchain, evaluate it. Otherwise, return value.
        '''
        if isinstance(value, JSchain):
            return value.eval()
        else:
            return value

    def __getattr__(self, attr):
        '''
        Called when using "." operator for the first time. Create a new chain and use it.
        Subsequent "." operators get processed by JSchain.
        '''
        # rasise any pending errors; these errors can get
        # generate on __del__() or other places that Python
        # will ignore.
        if self.state._error:
            e = self.state._error
            self.state._error = None
            raise e

        chain = JSchain(self.state)
        chain._add(attr)
        return chain

    def __setattr__(self, attr, value):
        '''
        Called when assiging attributes. This means no JSchain was created, so just process
        it directly.
        '''
        # if the value to be assigned is itself a JSchain, evaluate it
        value = JSroot._v(value)
        # don't process our own attributes
        if attr == "state" or attr == "linkset" or attr == "linkcall":
            super(JSroot, self).__setattr__(attr, value)
            return value
        # create a new JSchain
        c = self.__getattr__(attr)
        c.__setattr__(None, value)
        # c._add("=" + json.dumps(value), dot=False)
        return c

    def __getitem__(self, key):
        # this should never be called
        pass

    def __setitem__(self, key, value):
        value = JSroot._v(value)
        if key in self.linkcall:
            c = self.linkcall[key]
            if isinstance(c, JSchain):
                js = c._dup()
                if isinstance(value, list) or isinstance(value, tuple):
                    js.__call__(*value)
                else:
                    js.__call__(value)
            elif callable(c):
                c(value)
        elif key in self.linkset:
            c = self.linkset[key]
            if isinstance(c, JSchain):
                js = c._dup()
                js._add("=" + json.dumps(value), dot=False)

    def eval(self, stmt):
        '''
        Evaluate a Javascript statement `stmt` in on the Browser.
        '''
        chain = JSchain(self.state)
        chain._add(stmt)
        return chain.eval()

    def val(self, key, callback):
        self.linkset[key] = callback
        callback.keep = False

    def call(self, key, callback):
        self.linkcall[key] = callback
        if isinstance(callback, JSchain):
            callback.keep = False

    def __enter__(self):
        '''
        For use in "with" statements, as in:
            with server.js() as js:
                js.runme()
        '''
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="jyserver.JSCRIPT" class="name">var <span class="ident">JSCRIPT</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="jyserver.Client" class="name">class <span class="ident">Client</span></p>
      
  
    <div class="desc"><p>Client class contains all methods and code that is executed on the server
and browser. Users of this library should inherit this class and implement
methods. There are three types of methods:</p>
<h2>Attributes</h2>
<p>home
    Optional filename to send when "/" is requested
html
    Optional HTML to send when "/" is requested. If neither
    <code>home</code> nor <code>html</code> are set, then it will send "index.html"
js
    JS object for constructing and executing Javascript.</p>
<h2>Methods</h2>
<p>h(file, html)
    Return appropriate HTML for the active page. Can only
    be called once per page. Must be called if implementing
    custom pages.</p>
<h2>Optional Methods</h2>
<ul>
<li>
<p>main(self)</p>
<p>If this is implemented, then the server will begin execution of this
function immediately. The server will terminate when this function
terminates.</p>
</li>
<li>
<p>index(self)</p>
<p>If <code>index</code> is defined, it will execute this function. The function
is responsible for returning the HTML with the h() method.</p>
</li>
<li>
<p>page(self)</p>
<p>When the browser clicks on a link (or issues a GET) a method with the
name of the page is executed. For example, clicking on link "http:/pg1"
will cause a method named "pg1" to be executed.</p>
</li>
<li>
<p>func(self)</p>
<p>When the browser executes a "server" command, the server runs a method
with the same name. For example, if the browser runs the Javascript
code:</p>
<pre><code>server.addnum(15, 65)
</code></pre>
<p>then this method will be called:</p>
<pre><code>def func(self, 15, 65)
</code></pre>
</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Client', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Client" class="source">
    <pre><code>class Client:
    '''
    Client class contains all methods and code that is executed on the server
    and browser. Users of this library should inherit this class and implement
    methods. There are three types of methods:

    Attributes
    ------------
    home
        Optional filename to send when "/" is requested
    html
        Optional HTML to send when "/" is requested. If neither
        `home` nor `html` are set, then it will send "index.html"
    js
        JS object for constructing and executing Javascript.

    Methods
    -----------

    h(file, html)
        Return appropriate HTML for the active page. Can only
        be called once per page. Must be called if implementing
        custom pages.
    
    Optional Methods
    ------------
    * main(self)

        If this is implemented, then the server will begin execution of this
        function immediately. The server will terminate when this function
        terminates.

    * index(self)

        If `index` is defined, it will execute this function. The function
        is responsible for returning the HTML with the h() method.

    * page(self)

        When the browser clicks on a link (or issues a GET) a method with the
        name of the page is executed. For example, clicking on link "http:/pg1"
        will cause a method named "pg1" to be executed.

    * func(self)

        When the browser executes a "server" command, the server runs a method
        with the same name. For example, if the browser runs the Javascript
        code:

            server.addnum(15, 65)

        then this method will be called:

            def func(self, 15, 65)
    '''
    def __init__(self):
        self.js = None
        self._state = None

    def h(self, html=None, file=None):
        '''
        Convert text to html and wrap with script code. Return the HTML as a
        byte string. Must be called if implementing a custom page
        such as `index`.
        '''
        return self._state.htmlsend(html, file)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.Client">Client</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.Client.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Client.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Client.__init__" class="source">
    <pre><code>def __init__(self):
    self.js = None
    self._state = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Client.h">
    <p>def <span class="ident">h</span>(</p><p>self, html=None, file=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert text to html and wrap with script code. Return the HTML as a
byte string. Must be called if implementing a custom page
such as <code>index</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Client.h', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Client.h" class="source">
    <pre><code>def h(self, html=None, file=None):
    '''
    Convert text to html and wrap with script code. Return the HTML as a
    byte string. Must be called if implementing a custom page
    such as `index`.
    '''
    return self._state.htmlsend(html, file)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.Client.js" class="name">var <span class="ident">js</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.ClientContext" class="name">class <span class="ident">ClientContext</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext" class="source">
    <pre><code>class ClientContext:
    contextMap = {}
    taskTimeout = 5

    def __init__(self, cls, uid=None, verbose=False):
        self.appClass = cls
        self.obj = cls()
        self.queries = {}
        self.lock = threading.Lock()
        self.fxn = {}
        self.verbose = verbose
        self.tasks = queue.Queue()
        self.uid = uid
        self._error = None
        self._signal = None
        self.obj.js = JSroot(self)

    def render(self, html):
        # for Django support
        page = HtmlPage(html=html)
        html = page.html(self.uid)
        return html

    def render_django(self, inp):
        # for Django support
        page = HtmlPage(html=inp.content)
        inp.content = page.html(self.uid)
        return inp

    def htmlsend(self, html=None, file=None):
        page = HtmlPage(html=html, file=file)
        html = page.html(self.uid)
        self._handler.reply(html)
        self.log_message("SET SIGNAL %s", id(self._signal))
        self._signal.set()
        return page

    def hasMethod(self, name):
        return hasattr(self.obj, name)

    def callMethod(self, name, args=None):
        if hasattr(self.obj, name):
            f = getattr(self.obj, name)
            if args is None:
                f()
            else:
                f(*args)
        else:
            raise ValueError("Method not found: " + name)

    def __getattr__(self, attr):
        '''
        Unhandled calls to the context get routed to the app
        object.
        '''
        return self.obj.__getattribute__(attr)

    def getJS(self):
        return self.obj.js

    @classmethod
    def _getContextForPage(self, uid, appClass, create = False, verbose = False):
        '''
        Retrieve the Client instance for a given session id. If `create` is
        True, then if the app is not found a new one will be created. Otherwise
        if the app is not found, return None.
        '''
        if uid and not isinstance(uid, str):
            # if uid is a cookie, get it's value
            uid = uid.value

        # if we're not using cookies, direct links have uid of None
        if uid is None:
            # get first key
            if len(self.contextMap) > 0:
                uid = list(self.contextMap.items())[0][0]
            else:
                uid = None

        # existing app? return it
        if uid in self.contextMap:
            return self.contextMap[uid]
        else:
            # this is a new session or invalid session
            # assign it a new id
            # Instantiate Client, call initialize and save it.
            context = ClientContext(appClass, uid, verbose=verbose)
            self.contextMap[uid] = context
            context.log_message("NEW CONTEXT %s ID=%s", uid, id(self))
            # If there is a "main" function, then start a new thread to run it.
            # _mainRun will run main and terminate the server after main returns.
            context.mainRun()
            return context

        raise ValueError("Invalid or empty seession id: %s" % uid)

    def processCommand(self, req):
        pageid = req["session"]
        if pageid in HtmlPage.pageMap:
            self.uid = HtmlPage.pageMap[pageid]
        else:
            self.log_message("Invalid page id session %s", pageid)
            return 'Invalid pageid session: ' + pageid
            # raise RuntimeError("Invalid pageid session: " + pageid)

        HtmlPage.pageActive[pageid] = time.time()

        task = req["task"]
        self.log_message("RECEIVE TASK %s %s %s", task, self.uid, pageid)
        if task == "state":
            # The browser is replying to a request for data. First, find
            # the corresponding Queue for our request.
            q = self.getQuery(req['query'])
            # Add the results to the Queue, the code making the request is
            # currently waiting with a get(). This will cause that code
            # to wake up and process the results.
            q.put(req)
            # confirm to the server that we have processed this.
            return str(req)
        elif task == "run":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.run(req['function'], req['args'])
            return result
        elif task == "get":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.get(req['expression'])
            return result
        elif task == "set":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.set(req['property'], req['value'])
            return ''
        elif task == "async":
            # here, the browser is requesting we execute a statement and
            # return the results.
            result = self.run(req['function'], req['args'], block=False)
            return result
        elif task == "next":
            # the Browser is requesting we evaluate an expression and
            # return the results.
            script = self.getNextTask()
            self.log_message("NEXT TASK REQUESTED IS JS %s", script)
            return script
        elif task == "error":
            return ''
            # raise RuntimeError(req['error'] + ": " + req["expr"])
        elif task == "unload":
            self.addEndTask()
            HtmlPage.expire(pageid)
            # HtmlPage.raiseException(pageid, RuntimeError("unload"))
            self.log_message("UNLOAD %s", pageid)
            return ''

    def getQuery(self, query):
        '''
        Each query sent to the browser is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        return self.queries[query]

    def addQuery(self):
        '''
        Set query is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        q = queue.Queue()
        self.queries[id(q)] = q
        return id(q), q

    def delQuery(self, query):
        '''
        Delete query is assigned to it's own Queue to wait for 
        a response. This function returns the Queue for the given session id and query.
        '''
        return self.queries[query]

    def addTask(self, stmt):
        '''
        Add a task to the queue. If the queue is too long (5 in this case)
        the browser is too slow for the speed at which we are sending commands.
        In that case, wait for up to one second before sending the command.
        Perhaps the wait time and queue length should be configurable because they
        affect responsiveness.
        '''
        for _ in range(10):
            if self.tasks.qsize() < 5:
                self.tasks.put(stmt)
                self.log_message("ADD TASK %s ON %d", stmt, id(self.tasks))
                return
            time.sleep(0.1)
        self._error = TimeoutError("Timeout inserting task: " + stmt)


    def run(self, function, args, block=True):
        '''
        Called by the framework to execute a method. This function will look for a method
        with the given name. If it is found, it will execute it. If it is not found it
        will return a string saying so. If there is an error during execution it will
        return a string with the error message.
        '''
        self.log_message("RUN %s %s", function, args)
        if block:
            if not self.lock.acquire(blocking = False):
                raise RuntimeError("App is active and would block")
        
        try:
            if function == "_callfxn":
                # first argument is the function name
                # subsequent args are optional
                fxn = args.pop(0)
                f = self.fxn[fxn]
            elif callable(function):
                f = function
            elif hasattr(self.obj, function):
                f = getattr(self.obj, function)
            else:
                f = None

            if f:
                try:
                    result = f(*args)
                    ret = json.dumps({"value":JSroot._v(result)})
                except Exception as ex:
                    s = "%s: %s" % (type(ex).__name__, str(ex))
                    if self.verbose: traceback.print_exc()
                    self.log_message("Exception passed to browser: %s", s)
                    ret = json.dumps({"error":s})
            else:
                result = "Unsupported: " + function + "(" + str(args) + ")"
                ret = json.dumps({"error":str(result)})
            self.log_message("RUN RESULT %s", ret)
            return ret
        finally:
            if block:
                self.lock.release()

    def get(self, expr):
        '''
        Called by the framework to execute a method. This function will look for a method
        with the given name. If it is found, it will execute it. If it is not found it
        will return a string saying so. If there is an error during execution it will
        return a string with the error message.
        '''
        self.log_message("GET EXPR %s", expr)
        if not self.lock.acquire(blocking = False):
            raise RuntimeError("App is active and would block")
        
        try:
            if hasattr(self.obj, expr):
                value = getattr(self.obj, expr)
                if callable(value):
                    value = "(function(...args) { return handleApp('%s', args) })" % expr 
                    return json.dumps({"type":"expression", "expression":value})       
                else:
                    return json.dumps({"type":"value", "value":value})
            return None
        finally:
            self.lock.release()

    def set(self, expr, value):
        '''
        Called by the framework to set a propery.
        '''
        self.log_message("SET EXPR %s = %s", expr, value)
        self.obj.__setattr__(expr, value)
        return value

    def getNextTask(self):
        '''
        Wait for new tasks and return the next one. It will wait for 1 second and if
        there are no tasks return None.
        '''
        try:
            self.log_message("TASKS WAITING %d ON %d", self.tasks.qsize(), id(self.tasks))
            return self.tasks.get(timeout=self.taskTimeout)
        except queue.Empty:
            return None

    def addEndTask(self):
        '''
        Add a None task to end the queue.
        '''
        self.log_message("TASKS END %d ON %d", self.tasks.qsize(), id(self.tasks))
        self.tasks.put(None)

    def mainRun(self):
        if hasattr(self.obj, "main"):
            server_thread = threading.Thread(
                target=self.mainRunThread, daemon=True)
            server_thread.start()

    def mainRunThread(self):
        '''
        Run the main function. When the function ends, terminate the server.
        '''
        try:
            self.obj.main()
        except Exception as ex:
            self.log_message("FATAL ERROR: %s", ex)

    def showPage(self, handler, path, query):
        '''
        Called by framework to return a queried page. When the browser requests a web page
        (for example when a user clicks on a link), the path will get put in `path` and
        any paramters passed through GET or POST will get passed in `query`. This will
        look for a Client method with the same name as the page requested. If found, it will
        execute it and return the results. If not, it will return "not found", status 404.
        '''
        if callable(path):
            f = path
        else:
            fxn = path[1:].replace('/', '_').replace('.', '_')
            if hasattr(self.obj, fxn):
                f = getattr(self.obj, fxn)
            elif path == "/favicon.ico":
                handler.reply("Not found %s" % path, 404)
                return
            else:
                raise RuntimeWarning("Page not found: " + path)
                # return "Not found", 404

        self._handler = handler
        self._signal = threading.Event()
        self.log_message("START PAGE %s %d", path, id(self._signal))
        server_thread = threading.Thread(target=self.run_callable, 
                args=(f, {"page": path, "query": query}), daemon=True)
        server_thread.start()
        self.log_message("WAIT ON SIGNAL %s %d", path, id(self._signal))
        self._signal.wait() # set when HTML is sent
        self._signal = None

    def run_callable(self, f, args):
        params = signature(f).parameters
        try:
            if len(params) == 0:
                f()
            else:
                f(args)
        except Exception as ex:
            traceback.print_exc()
            self.log_message("Exception: %s" % str(ex))

    def showHome(self):
        '''
        Get the home page when "/" is queried and inject the appropriate javascript
        code. Returns a byte string suitable for replying back to the browser.
        '''
        if hasattr(self.obj, "html"):
            block = self.obj.html.encode("utf8")
            page = HtmlPage(block)
            self.activePage = page.pageid
            return page.html(self.uid)
        elif hasattr(self.obj, "home"):
            path = self.obj.home
        elif os.path.exists("index.html"):
            path = "index.html"
        elif hasattr(self.obj, "index"):
            return self.obj.index
        else:
            raise ValueError("Could not find index or home")

        with open(path, "rb") as f:
            block = f.read()
            page = HtmlPage(block)
            self.activePage = page.pageid
            return page.html(self.uid)

    def log_message(self, format, *args):
        if self.verbose:
            print(format % args)

    def log_error(self, format, *args):
        print(format % args)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.ClientContext">ClientContext</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="jyserver.ClientContext.contextMap" class="name">var <span class="ident">contextMap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.taskTimeout" class="name">var <span class="ident">taskTimeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, cls, uid=None, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.__init__" class="source">
    <pre><code>def __init__(self, cls, uid=None, verbose=False):
    self.appClass = cls
    self.obj = cls()
    self.queries = {}
    self.lock = threading.Lock()
    self.fxn = {}
    self.verbose = verbose
    self.tasks = queue.Queue()
    self.uid = uid
    self._error = None
    self._signal = None
    self.obj.js = JSroot(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.addEndTask">
    <p>def <span class="ident">addEndTask</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a None task to end the queue.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.addEndTask', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.addEndTask" class="source">
    <pre><code>def addEndTask(self):
    '''
    Add a None task to end the queue.
    '''
    self.log_message("TASKS END %d ON %d", self.tasks.qsize(), id(self.tasks))
    self.tasks.put(None)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.addQuery">
    <p>def <span class="ident">addQuery</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set query is assigned to it's own Queue to wait for 
a response. This function returns the Queue for the given session id and query.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.addQuery', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.addQuery" class="source">
    <pre><code>def addQuery(self):
    '''
    Set query is assigned to it's own Queue to wait for 
    a response. This function returns the Queue for the given session id and query.
    '''
    q = queue.Queue()
    self.queries[id(q)] = q
    return id(q), q
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.addTask">
    <p>def <span class="ident">addTask</span>(</p><p>self, stmt)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a task to the queue. If the queue is too long (5 in this case)
the browser is too slow for the speed at which we are sending commands.
In that case, wait for up to one second before sending the command.
Perhaps the wait time and queue length should be configurable because they
affect responsiveness.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.addTask', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.addTask" class="source">
    <pre><code>def addTask(self, stmt):
    '''
    Add a task to the queue. If the queue is too long (5 in this case)
    the browser is too slow for the speed at which we are sending commands.
    In that case, wait for up to one second before sending the command.
    Perhaps the wait time and queue length should be configurable because they
    affect responsiveness.
    '''
    for _ in range(10):
        if self.tasks.qsize() < 5:
            self.tasks.put(stmt)
            self.log_message("ADD TASK %s ON %d", stmt, id(self.tasks))
            return
        time.sleep(0.1)
    self._error = TimeoutError("Timeout inserting task: " + stmt)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.callMethod">
    <p>def <span class="ident">callMethod</span>(</p><p>self, name, args=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.callMethod', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.callMethod" class="source">
    <pre><code>def callMethod(self, name, args=None):
    if hasattr(self.obj, name):
        f = getattr(self.obj, name)
        if args is None:
            f()
        else:
            f(*args)
    else:
        raise ValueError("Method not found: " + name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.delQuery">
    <p>def <span class="ident">delQuery</span>(</p><p>self, query)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete query is assigned to it's own Queue to wait for 
a response. This function returns the Queue for the given session id and query.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.delQuery', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.delQuery" class="source">
    <pre><code>def delQuery(self, query):
    '''
    Delete query is assigned to it's own Queue to wait for 
    a response. This function returns the Queue for the given session id and query.
    '''
    return self.queries[query]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.get">
    <p>def <span class="ident">get</span>(</p><p>self, expr)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by the framework to execute a method. This function will look for a method
with the given name. If it is found, it will execute it. If it is not found it
will return a string saying so. If there is an error during execution it will
return a string with the error message.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.get', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.get" class="source">
    <pre><code>def get(self, expr):
    '''
    Called by the framework to execute a method. This function will look for a method
    with the given name. If it is found, it will execute it. If it is not found it
    will return a string saying so. If there is an error during execution it will
    return a string with the error message.
    '''
    self.log_message("GET EXPR %s", expr)
    if not self.lock.acquire(blocking = False):
        raise RuntimeError("App is active and would block")
    
    try:
        if hasattr(self.obj, expr):
            value = getattr(self.obj, expr)
            if callable(value):
                value = "(function(...args) { return handleApp('%s', args) })" % expr 
                return json.dumps({"type":"expression", "expression":value})       
            else:
                return json.dumps({"type":"value", "value":value})
        return None
    finally:
        self.lock.release()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.getJS">
    <p>def <span class="ident">getJS</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.getJS', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.getJS" class="source">
    <pre><code>def getJS(self):
    return self.obj.js
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.getNextTask">
    <p>def <span class="ident">getNextTask</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for new tasks and return the next one. It will wait for 1 second and if
there are no tasks return None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.getNextTask', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.getNextTask" class="source">
    <pre><code>def getNextTask(self):
    '''
    Wait for new tasks and return the next one. It will wait for 1 second and if
    there are no tasks return None.
    '''
    try:
        self.log_message("TASKS WAITING %d ON %d", self.tasks.qsize(), id(self.tasks))
        return self.tasks.get(timeout=self.taskTimeout)
    except queue.Empty:
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.getQuery">
    <p>def <span class="ident">getQuery</span>(</p><p>self, query)</p>
    </div>
    

    
  
    <div class="desc"><p>Each query sent to the browser is assigned to it's own Queue to wait for 
a response. This function returns the Queue for the given session id and query.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.getQuery', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.getQuery" class="source">
    <pre><code>def getQuery(self, query):
    '''
    Each query sent to the browser is assigned to it's own Queue to wait for 
    a response. This function returns the Queue for the given session id and query.
    '''
    return self.queries[query]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.hasMethod">
    <p>def <span class="ident">hasMethod</span>(</p><p>self, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.hasMethod', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.hasMethod" class="source">
    <pre><code>def hasMethod(self, name):
    return hasattr(self.obj, name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.htmlsend">
    <p>def <span class="ident">htmlsend</span>(</p><p>self, html=None, file=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.htmlsend', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.htmlsend" class="source">
    <pre><code>def htmlsend(self, html=None, file=None):
    page = HtmlPage(html=html, file=file)
    html = page.html(self.uid)
    self._handler.reply(html)
    self.log_message("SET SIGNAL %s", id(self._signal))
    self._signal.set()
    return page
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.log_error">
    <p>def <span class="ident">log_error</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.log_error', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.log_error" class="source">
    <pre><code>def log_error(self, format, *args):
    print(format % args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.log_message">
    <p>def <span class="ident">log_message</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.log_message', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.log_message" class="source">
    <pre><code>def log_message(self, format, *args):
    if self.verbose:
        print(format % args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.mainRun">
    <p>def <span class="ident">mainRun</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.mainRun', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.mainRun" class="source">
    <pre><code>def mainRun(self):
    if hasattr(self.obj, "main"):
        server_thread = threading.Thread(
            target=self.mainRunThread, daemon=True)
        server_thread.start()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.mainRunThread">
    <p>def <span class="ident">mainRunThread</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the main function. When the function ends, terminate the server.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.mainRunThread', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.mainRunThread" class="source">
    <pre><code>def mainRunThread(self):
    '''
    Run the main function. When the function ends, terminate the server.
    '''
    try:
        self.obj.main()
    except Exception as ex:
        self.log_message("FATAL ERROR: %s", ex)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.processCommand">
    <p>def <span class="ident">processCommand</span>(</p><p>self, req)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.processCommand', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.processCommand" class="source">
    <pre><code>def processCommand(self, req):
    pageid = req["session"]
    if pageid in HtmlPage.pageMap:
        self.uid = HtmlPage.pageMap[pageid]
    else:
        self.log_message("Invalid page id session %s", pageid)
        return 'Invalid pageid session: ' + pageid
        # raise RuntimeError("Invalid pageid session: " + pageid)
    HtmlPage.pageActive[pageid] = time.time()
    task = req["task"]
    self.log_message("RECEIVE TASK %s %s %s", task, self.uid, pageid)
    if task == "state":
        # The browser is replying to a request for data. First, find
        # the corresponding Queue for our request.
        q = self.getQuery(req['query'])
        # Add the results to the Queue, the code making the request is
        # currently waiting with a get(). This will cause that code
        # to wake up and process the results.
        q.put(req)
        # confirm to the server that we have processed this.
        return str(req)
    elif task == "run":
        # here, the browser is requesting we execute a statement and
        # return the results.
        result = self.run(req['function'], req['args'])
        return result
    elif task == "get":
        # here, the browser is requesting we execute a statement and
        # return the results.
        result = self.get(req['expression'])
        return result
    elif task == "set":
        # here, the browser is requesting we execute a statement and
        # return the results.
        result = self.set(req['property'], req['value'])
        return ''
    elif task == "async":
        # here, the browser is requesting we execute a statement and
        # return the results.
        result = self.run(req['function'], req['args'], block=False)
        return result
    elif task == "next":
        # the Browser is requesting we evaluate an expression and
        # return the results.
        script = self.getNextTask()
        self.log_message("NEXT TASK REQUESTED IS JS %s", script)
        return script
    elif task == "error":
        return ''
        # raise RuntimeError(req['error'] + ": " + req["expr"])
    elif task == "unload":
        self.addEndTask()
        HtmlPage.expire(pageid)
        # HtmlPage.raiseException(pageid, RuntimeError("unload"))
        self.log_message("UNLOAD %s", pageid)
        return ''
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.render">
    <p>def <span class="ident">render</span>(</p><p>self, html)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.render', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.render" class="source">
    <pre><code>def render(self, html):
    # for Django support
    page = HtmlPage(html=html)
    html = page.html(self.uid)
    return html
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.render_django">
    <p>def <span class="ident">render_django</span>(</p><p>self, inp)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.render_django', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.render_django" class="source">
    <pre><code>def render_django(self, inp):
    # for Django support
    page = HtmlPage(html=inp.content)
    inp.content = page.html(self.uid)
    return inp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.run">
    <p>def <span class="ident">run</span>(</p><p>self, function, args, block=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by the framework to execute a method. This function will look for a method
with the given name. If it is found, it will execute it. If it is not found it
will return a string saying so. If there is an error during execution it will
return a string with the error message.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.run', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.run" class="source">
    <pre><code>def run(self, function, args, block=True):
    '''
    Called by the framework to execute a method. This function will look for a method
    with the given name. If it is found, it will execute it. If it is not found it
    will return a string saying so. If there is an error during execution it will
    return a string with the error message.
    '''
    self.log_message("RUN %s %s", function, args)
    if block:
        if not self.lock.acquire(blocking = False):
            raise RuntimeError("App is active and would block")
    
    try:
        if function == "_callfxn":
            # first argument is the function name
            # subsequent args are optional
            fxn = args.pop(0)
            f = self.fxn[fxn]
        elif callable(function):
            f = function
        elif hasattr(self.obj, function):
            f = getattr(self.obj, function)
        else:
            f = None
        if f:
            try:
                result = f(*args)
                ret = json.dumps({"value":JSroot._v(result)})
            except Exception as ex:
                s = "%s: %s" % (type(ex).__name__, str(ex))
                if self.verbose: traceback.print_exc()
                self.log_message("Exception passed to browser: %s", s)
                ret = json.dumps({"error":s})
        else:
            result = "Unsupported: " + function + "(" + str(args) + ")"
            ret = json.dumps({"error":str(result)})
        self.log_message("RUN RESULT %s", ret)
        return ret
    finally:
        if block:
            self.lock.release()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.run_callable">
    <p>def <span class="ident">run_callable</span>(</p><p>self, f, args)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.run_callable', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.run_callable" class="source">
    <pre><code>def run_callable(self, f, args):
    params = signature(f).parameters
    try:
        if len(params) == 0:
            f()
        else:
            f(args)
    except Exception as ex:
        traceback.print_exc()
        self.log_message("Exception: %s" % str(ex))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.set">
    <p>def <span class="ident">set</span>(</p><p>self, expr, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by the framework to set a propery.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.set', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.set" class="source">
    <pre><code>def set(self, expr, value):
    '''
    Called by the framework to set a propery.
    '''
    self.log_message("SET EXPR %s = %s", expr, value)
    self.obj.__setattr__(expr, value)
    return value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.showHome">
    <p>def <span class="ident">showHome</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the home page when "/" is queried and inject the appropriate javascript
code. Returns a byte string suitable for replying back to the browser.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.showHome', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.showHome" class="source">
    <pre><code>def showHome(self):
    '''
    Get the home page when "/" is queried and inject the appropriate javascript
    code. Returns a byte string suitable for replying back to the browser.
    '''
    if hasattr(self.obj, "html"):
        block = self.obj.html.encode("utf8")
        page = HtmlPage(block)
        self.activePage = page.pageid
        return page.html(self.uid)
    elif hasattr(self.obj, "home"):
        path = self.obj.home
    elif os.path.exists("index.html"):
        path = "index.html"
    elif hasattr(self.obj, "index"):
        return self.obj.index
    else:
        raise ValueError("Could not find index or home")
    with open(path, "rb") as f:
        block = f.read()
        page = HtmlPage(block)
        self.activePage = page.pageid
        return page.html(self.uid)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.ClientContext.showPage">
    <p>def <span class="ident">showPage</span>(</p><p>self, handler, path, query)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by framework to return a queried page. When the browser requests a web page
(for example when a user clicks on a link), the path will get put in <code>path</code> and
any paramters passed through GET or POST will get passed in <code>query</code>. This will
look for a Client method with the same name as the page requested. If found, it will
execute it and return the results. If not, it will return "not found", status 404.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.ClientContext.showPage', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.ClientContext.showPage" class="source">
    <pre><code>def showPage(self, handler, path, query):
    '''
    Called by framework to return a queried page. When the browser requests a web page
    (for example when a user clicks on a link), the path will get put in `path` and
    any paramters passed through GET or POST will get passed in `query`. This will
    look for a Client method with the same name as the page requested. If found, it will
    execute it and return the results. If not, it will return "not found", status 404.
    '''
    if callable(path):
        f = path
    else:
        fxn = path[1:].replace('/', '_').replace('.', '_')
        if hasattr(self.obj, fxn):
            f = getattr(self.obj, fxn)
        elif path == "/favicon.ico":
            handler.reply("Not found %s" % path, 404)
            return
        else:
            raise RuntimeWarning("Page not found: " + path)
            # return "Not found", 404
    self._handler = handler
    self._signal = threading.Event()
    self.log_message("START PAGE %s %d", path, id(self._signal))
    server_thread = threading.Thread(target=self.run_callable, 
            args=(f, {"page": path, "query": query}), daemon=True)
    server_thread.start()
    self.log_message("WAIT ON SIGNAL %s %d", path, id(self._signal))
    self._signal.wait() # set when HTML is sent
    self._signal = None
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.ClientContext.appClass" class="name">var <span class="ident">appClass</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.fxn" class="name">var <span class="ident">fxn</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.lock" class="name">var <span class="ident">lock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.obj" class="name">var <span class="ident">obj</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.queries" class="name">var <span class="ident">queries</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.tasks" class="name">var <span class="ident">tasks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.uid" class="name">var <span class="ident">uid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.ClientContext.verbose" class="name">var <span class="ident">verbose</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.Handler" class="name">class <span class="ident">Handler</span></p>
      
  
    <div class="desc"><p>Handler is created for each request by the Server. This class
handles the page requests and delegates tasks.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler" class="source">
    <pre><code>class Handler(SimpleHTTPRequestHandler):
    '''
    Handler is created for each request by the Server. This class
    handles the page requests and delegates tasks.
    '''

    def getContext(self):
        return self.server._getContextForPage(self.uid)

    def reply(self, data, num=200):
        '''
        Reply to the client with the given status code. If data is given as a string
        it will be encoded at utf8. Cookies are sent if they are used.
        '''
        self.send_response(num)
        if self.server.useCookies:
            self.send_header(
                "Set-Cookie", self.cookies.output(header='', sep=''))
        self.end_headers()

        if data is None:
            return

        if isinstance(data, str):
            data = data.encode("utf8")

        try:
            self.wfile.write(data)
            self.log_message("REPLY DONE")
        except Exception as ex:
            traceback.print_exc()
            self.server.log_error("Error sending: %s", str(ex))

    def replyFile(self, path, num=200):
        '''
        Reply to client with given file.
        '''
        with open(path, "rb") as f:
            block = f.read()
            result = HtmlPage(block).html(self.uid)
            self.reply(result)

    def processCookies(self):
        '''
        Read in cookies and extract the session id.
        '''
        if self.server.useCookies:
            self.cookies = SimpleCookie(self.headers.get('Cookie'))
            if "UID" in self.cookies:
                self.uid = self.cookies["UID"]
            else:
                self.uid = None

    def do_GET(self):
        '''
        Called by parent to process GET requests. Forwards requests to do_PAGE.
        '''
        if not self.server._runmode: return
        self.processCookies()
        qry = urlparse(self.path)
        req = dict(parse_qsl(qry.query))
        self.server.log_message("GET %s %s", qry, req)
        if "session" in req:
            pageid = req["session"]
            self.uid = HtmlPage.pageMap[pageid]
        else:
            self.uid = None
            # self.setNewUID()

        if qry.path == "/":
            # result = self.server._getHome(self.uid)
            c = self.getContext()
            result = c.showHome()
            if callable(result):
                self.log_message("HOME CALL %s", result)
                c.showPage(self, result, qry)
            else:
                self.log_message("HOME SEND %s", result)
                self.reply(result)
        elif qry.path == "/appscript.js":
            self.reply(JSCRIPT)
        else:
            self.do_PAGE(qry)

    def do_POST(self):
        '''
        Called by parent to process POST requests. Handles the built-in
        /state and /run requests and forwards all others to do_PAGE.
        '''
        if not self.server._runmode: return
        self.processCookies()
        l = int(self.headers["Content-length"])
        data = self.rfile.read(l)
        self.log_message("HTTP POST %s", data)
        if self.path == "/_process_srv0":
            self.log_message("PROCESS %s", data)
            req = json.loads(data)  
            c = self.getContext()
            results = c.processCommand(req)
            self.reply(results)
        else:
            self.do_PAGE(data)

    def do_PAGE(self, qry):
        '''
        Process page requests except /state and /run.
        '''
        self.log_message("PAGE %s", qry)
        if os.path.exists(qry.path[1:]):
            # try to send a file with the given name if it exists.
            self.replyFile(qry.path[1:])
        else:
            # otherwise, pass on the request to the Client object. It will
            # execute a method with the same name if it exists.
            c = self.getContext()
            c.showPage(self, qry.path, qry)

    def log_message(self, format, *args):
        if self.server.verbose:
            print(format % args)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.Handler">Handler</a></li>
          <li>http.server.SimpleHTTPRequestHandler</li>
          <li>http.server.BaseHTTPRequestHandler</li>
          <li>socketserver.StreamRequestHandler</li>
          <li>socketserver.BaseRequestHandler</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="jyserver.Handler.MessageClass" class="name">var <span class="ident">MessageClass</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.default_request_version" class="name">var <span class="ident">default_request_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.disable_nagle_algorithm" class="name">var <span class="ident">disable_nagle_algorithm</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.error_content_type" class="name">var <span class="ident">error_content_type</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.error_message_format" class="name">var <span class="ident">error_message_format</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.extensions_map" class="name">var <span class="ident">extensions_map</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.monthname" class="name">var <span class="ident">monthname</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.protocol_version" class="name">var <span class="ident">protocol_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.rbufsize" class="name">var <span class="ident">rbufsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.responses" class="name">var <span class="ident">responses</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.server_version" class="name">var <span class="ident">server_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.sys_version" class="name">var <span class="ident">sys_version</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.timeout" class="name">var <span class="ident">timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.wbufsize" class="name">var <span class="ident">wbufsize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Handler.weekdayname" class="name">var <span class="ident">weekdayname</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.__init__" class="source">
    <pre><code>def __init__(self, *args, directory=None, **kwargs):
    if directory is None:
        directory = os.getcwd()
    self.directory = directory
    super().__init__(*args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.address_string">
    <p>def <span class="ident">address_string</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the client address.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.address_string', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.address_string" class="source">
    <pre><code>def address_string(self):
    """Return the client address."""
    return self.client_address[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.copyfile">
    <p>def <span class="ident">copyfile</span>(</p><p>self, source, outputfile)</p>
    </div>
    

    
  
    <div class="desc"><p>Copy all data between two file objects.</p>
<p>The SOURCE argument is a file object open for reading
(or anything with a read() method) and the DESTINATION
argument is a file object open for writing (or
anything with a write() method).</p>
<p>The only reason for overriding this would be to change
the block size or perhaps to replace newlines by CRLF
-- note however that this the default server uses this
to copy binary data as well.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.copyfile', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.copyfile" class="source">
    <pre><code>def copyfile(self, source, outputfile):
    """Copy all data between two file objects.
    The SOURCE argument is a file object open for reading
    (or anything with a read() method) and the DESTINATION
    argument is a file object open for writing (or
    anything with a write() method).
    The only reason for overriding this would be to change
    the block size or perhaps to replace newlines by CRLF
    -- note however that this the default server uses this
    to copy binary data as well.
    """
    shutil.copyfileobj(source, outputfile)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.date_time_string">
    <p>def <span class="ident">date_time_string</span>(</p><p>self, timestamp=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the current date and time formatted for a message header.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.date_time_string', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.date_time_string" class="source">
    <pre><code>def date_time_string(self, timestamp=None):
    """Return the current date and time formatted for a message header."""
    if timestamp is None:
        timestamp = time.time()
    return email.utils.formatdate(timestamp, usegmt=True)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.do_GET">
    <p>def <span class="ident">do_GET</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by parent to process GET requests. Forwards requests to do_PAGE.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.do_GET', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.do_GET" class="source">
    <pre><code>def do_GET(self):
    '''
    Called by parent to process GET requests. Forwards requests to do_PAGE.
    '''
    if not self.server._runmode: return
    self.processCookies()
    qry = urlparse(self.path)
    req = dict(parse_qsl(qry.query))
    self.server.log_message("GET %s %s", qry, req)
    if "session" in req:
        pageid = req["session"]
        self.uid = HtmlPage.pageMap[pageid]
    else:
        self.uid = None
        # self.setNewUID()
    if qry.path == "/":
        # result = self.server._getHome(self.uid)
        c = self.getContext()
        result = c.showHome()
        if callable(result):
            self.log_message("HOME CALL %s", result)
            c.showPage(self, result, qry)
        else:
            self.log_message("HOME SEND %s", result)
            self.reply(result)
    elif qry.path == "/appscript.js":
        self.reply(JSCRIPT)
    else:
        self.do_PAGE(qry)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.do_HEAD">
    <p>def <span class="ident">do_HEAD</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Serve a HEAD request.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.do_HEAD', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.do_HEAD" class="source">
    <pre><code>def do_HEAD(self):
    """Serve a HEAD request."""
    f = self.send_head()
    if f:
        f.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.do_PAGE">
    <p>def <span class="ident">do_PAGE</span>(</p><p>self, qry)</p>
    </div>
    

    
  
    <div class="desc"><p>Process page requests except /state and /run.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.do_PAGE', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.do_PAGE" class="source">
    <pre><code>def do_PAGE(self, qry):
    '''
    Process page requests except /state and /run.
    '''
    self.log_message("PAGE %s", qry)
    if os.path.exists(qry.path[1:]):
        # try to send a file with the given name if it exists.
        self.replyFile(qry.path[1:])
    else:
        # otherwise, pass on the request to the Client object. It will
        # execute a method with the same name if it exists.
        c = self.getContext()
        c.showPage(self, qry.path, qry)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.do_POST">
    <p>def <span class="ident">do_POST</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by parent to process POST requests. Handles the built-in
/state and /run requests and forwards all others to do_PAGE.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.do_POST', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.do_POST" class="source">
    <pre><code>def do_POST(self):
    '''
    Called by parent to process POST requests. Handles the built-in
    /state and /run requests and forwards all others to do_PAGE.
    '''
    if not self.server._runmode: return
    self.processCookies()
    l = int(self.headers["Content-length"])
    data = self.rfile.read(l)
    self.log_message("HTTP POST %s", data)
    if self.path == "/_process_srv0":
        self.log_message("PROCESS %s", data)
        req = json.loads(data)  
        c = self.getContext()
        results = c.processCommand(req)
        self.reply(results)
    else:
        self.do_PAGE(data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.end_headers">
    <p>def <span class="ident">end_headers</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Send the blank line ending the MIME headers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.end_headers', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.end_headers" class="source">
    <pre><code>def end_headers(self):
    """Send the blank line ending the MIME headers."""
    if self.request_version != 'HTTP/0.9':
        self._headers_buffer.append(b"\r\n")
        self.flush_headers()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.finish">
    <p>def <span class="ident">finish</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.finish', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.finish" class="source">
    <pre><code>def finish(self):
    if not self.wfile.closed:
        try:
            self.wfile.flush()
        except socket.error:
            # A final socket error may have occurred here, such as
            # the local error ECONNABORTED.
            pass
    self.wfile.close()
    self.rfile.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.flush_headers">
    <p>def <span class="ident">flush_headers</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.flush_headers', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.flush_headers" class="source">
    <pre><code>def flush_headers(self):
    if hasattr(self, '_headers_buffer'):
        self.wfile.write(b"".join(self._headers_buffer))
        self._headers_buffer = []
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.getContext">
    <p>def <span class="ident">getContext</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.getContext', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.getContext" class="source">
    <pre><code>def getContext(self):
    return self.server._getContextForPage(self.uid)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.guess_type">
    <p>def <span class="ident">guess_type</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>Guess the type of a file.</p>
<p>Argument is a PATH (a filename).</p>
<p>Return value is a string of the form type/subtype,
usable for a MIME Content-type header.</p>
<p>The default implementation looks the file's extension
up in the table self.extensions_map, using application/octet-stream
as a default; however it would be permissible (if
slow) to look inside the data to make a better guess.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.guess_type', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.guess_type" class="source">
    <pre><code>def guess_type(self, path):
    """Guess the type of a file.
    Argument is a PATH (a filename).
    Return value is a string of the form type/subtype,
    usable for a MIME Content-type header.
    The default implementation looks the file's extension
    up in the table self.extensions_map, using application/octet-stream
    as a default; however it would be permissible (if
    slow) to look inside the data to make a better guess.
    """
    base, ext = posixpath.splitext(path)
    if ext in self.extensions_map:
        return self.extensions_map[ext]
    ext = ext.lower()
    if ext in self.extensions_map:
        return self.extensions_map[ext]
    else:
        return self.extensions_map['']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.handle">
    <p>def <span class="ident">handle</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle multiple requests if necessary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.handle', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.handle" class="source">
    <pre><code>def handle(self):
    """Handle multiple requests if necessary."""
    self.close_connection = True
    self.handle_one_request()
    while not self.close_connection:
        self.handle_one_request()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.handle_expect_100">
    <p>def <span class="ident">handle_expect_100</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Decide what to do with an "Expect: 100-continue" header.</p>
<p>If the client is expecting a 100 Continue response, we must
respond with either a 100 Continue or a final response before
waiting for the request body. The default is to always respond
with a 100 Continue. You can behave differently (for example,
reject unauthorized requests) by overriding this method.</p>
<p>This method should either return True (possibly after sending
a 100 Continue response) or send an error response and return
False.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.handle_expect_100', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.handle_expect_100" class="source">
    <pre><code>def handle_expect_100(self):
    """Decide what to do with an "Expect: 100-continue" header.
    If the client is expecting a 100 Continue response, we must
    respond with either a 100 Continue or a final response before
    waiting for the request body. The default is to always respond
    with a 100 Continue. You can behave differently (for example,
    reject unauthorized requests) by overriding this method.
    This method should either return True (possibly after sending
    a 100 Continue response) or send an error response and return
    False.
    """
    self.send_response_only(HTTPStatus.CONTINUE)
    self.end_headers()
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.handle_one_request">
    <p>def <span class="ident">handle_one_request</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle a single HTTP request.</p>
<p>You normally don't need to override this method; see the class
<strong>doc</strong> string for information on how to handle specific HTTP
commands such as GET and POST.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.handle_one_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.handle_one_request" class="source">
    <pre><code>def handle_one_request(self):
    """Handle a single HTTP request.
    You normally don't need to override this method; see the class
    __doc__ string for information on how to handle specific HTTP
    commands such as GET and POST.
    """
    try:
        self.raw_requestline = self.rfile.readline(65537)
        if len(self.raw_requestline) > 65536:
            self.requestline = ''
            self.request_version = ''
            self.command = ''
            self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)
            return
        if not self.raw_requestline:
            self.close_connection = True
            return
        if not self.parse_request():
            # An error code has been sent, just exit
            return
        mname = 'do_' + self.command
        if not hasattr(self, mname):
            self.send_error(
                HTTPStatus.NOT_IMPLEMENTED,
                "Unsupported method (%r)" % self.command)
            return
        method = getattr(self, mname)
        method()
        self.wfile.flush() #actually send the response if not already done.
    except socket.timeout as e:
        #a read or a write timed out.  Discard this connection
        self.log_error("Request timed out: %r", e)
        self.close_connection = True
        return
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.list_directory">
    <p>def <span class="ident">list_directory</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>Helper to produce a directory listing (absent index.html).</p>
<p>Return value is either a file object, or None (indicating an
error).  In either case, the headers are sent, making the
interface the same as for send_head().</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.list_directory', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.list_directory" class="source">
    <pre><code>def list_directory(self, path):
    """Helper to produce a directory listing (absent index.html).
    Return value is either a file object, or None (indicating an
    error).  In either case, the headers are sent, making the
    interface the same as for send_head().
    """
    try:
        list = os.listdir(path)
    except OSError:
        self.send_error(
            HTTPStatus.NOT_FOUND,
            "No permission to list directory")
        return None
    list.sort(key=lambda a: a.lower())
    r = []
    try:
        displaypath = urllib.parse.unquote(self.path,
                                           errors='surrogatepass')
    except UnicodeDecodeError:
        displaypath = urllib.parse.unquote(path)
    displaypath = html.escape(displaypath, quote=False)
    enc = sys.getfilesystemencoding()
    title = 'Directory listing for %s' % displaypath
    r.append('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
             '"http://www.w3.org/TR/html4/strict.dtd">')
    r.append('<html>\n<head>')
    r.append('<meta http-equiv="Content-Type" '
             'content="text/html; charset=%s">' % enc)
    r.append('<title>%s</title>\n</head>' % title)
    r.append('<body>\n<h1>%s</h1>' % title)
    r.append('<hr>\n<ul>')
    for name in list:
        fullname = os.path.join(path, name)
        displayname = linkname = name
        # Append / for directories or @ for symbolic links
        if os.path.isdir(fullname):
            displayname = name + "/"
            linkname = name + "/"
        if os.path.islink(fullname):
            displayname = name + "@"
            # Note: a link to a directory displays with @ and links with /
        r.append('<li><a href="%s">%s</a></li>'
                % (urllib.parse.quote(linkname,
                                      errors='surrogatepass'),
                   html.escape(displayname, quote=False)))
    r.append('</ul>\n<hr>\n</body>\n</html>\n')
    encoded = '\n'.join(r).encode(enc, 'surrogateescape')
    f = io.BytesIO()
    f.write(encoded)
    f.seek(0)
    self.send_response(HTTPStatus.OK)
    self.send_header("Content-type", "text/html; charset=%s" % enc)
    self.send_header("Content-Length", str(len(encoded)))
    self.end_headers()
    return f
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.log_date_time_string">
    <p>def <span class="ident">log_date_time_string</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the current time formatted for logging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.log_date_time_string', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.log_date_time_string" class="source">
    <pre><code>def log_date_time_string(self):
    """Return the current time formatted for logging."""
    now = time.time()
    year, month, day, hh, mm, ss, x, y, z = time.localtime(now)
    s = "%02d/%3s/%04d %02d:%02d:%02d" % (
            day, self.monthname[month], year, hh, mm, ss)
    return s
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.log_error">
    <p>def <span class="ident">log_error</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
    <div class="desc"><p>Log an error.</p>
<p>This is called when a request cannot be fulfilled.  By
default it passes the message on to log_message().</p>
<p>Arguments are the same as for log_message().</p>
<p>XXX This should go to the separate error log.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.log_error', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.log_error" class="source">
    <pre><code>def log_error(self, format, *args):
    """Log an error.
    This is called when a request cannot be fulfilled.  By
    default it passes the message on to log_message().
    Arguments are the same as for log_message().
    XXX This should go to the separate error log.
    """
    self.log_message(format, *args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.log_message">
    <p>def <span class="ident">log_message</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
    <div class="desc"><p>Log an arbitrary message.</p>
<p>This is used by all other logging functions.  Override
it if you have specific logging wishes.</p>
<p>The first argument, FORMAT, is a format string for the
message to be logged.  If the format string contains
any % escapes requiring parameters, they should be
specified as subsequent arguments (it's just like
printf!).</p>
<p>The client ip and current date/time are prefixed to
every message.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.log_message', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.log_message" class="source">
    <pre><code>def log_message(self, format, *args):
    if self.server.verbose:
        print(format % args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.log_request">
    <p>def <span class="ident">log_request</span>(</p><p>self, code=&#39;-&#39;, size=&#39;-&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Log an accepted request.</p>
<p>This is called by send_response().</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.log_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.log_request" class="source">
    <pre><code>def log_request(self, code='-', size='-'):
    """Log an accepted request.
    This is called by send_response().
    """
    if isinstance(code, HTTPStatus):
        code = code.value
    self.log_message('"%s" %s %s',
                     self.requestline, str(code), str(size))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.parse_request">
    <p>def <span class="ident">parse_request</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Parse a request (internal).</p>
<p>The request should be stored in self.raw_requestline; the results
are in self.command, self.path, self.request_version and
self.headers.</p>
<p>Return True for success, False for failure; on failure, any relevant
error response has already been sent back.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.parse_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.parse_request" class="source">
    <pre><code>def parse_request(self):
    """Parse a request (internal).
    The request should be stored in self.raw_requestline; the results
    are in self.command, self.path, self.request_version and
    self.headers.
    Return True for success, False for failure; on failure, any relevant
    error response has already been sent back.
    """
    self.command = None  # set in case of error on the first line
    self.request_version = version = self.default_request_version
    self.close_connection = True
    requestline = str(self.raw_requestline, 'iso-8859-1')
    requestline = requestline.rstrip('\r\n')
    self.requestline = requestline
    words = requestline.split()
    if len(words) == 0:
        return False
    if len(words) >= 3:  # Enough to determine protocol version
        version = words[-1]
        try:
            if not version.startswith('HTTP/'):
                raise ValueError
            base_version_number = version.split('/', 1)[1]
            version_number = base_version_number.split(".")
            # RFC 2145 section 3.1 says there can be only one "." and
            #   - major and minor numbers MUST be treated as
            #      separate integers;
            #   - HTTP/2.4 is a lower version than HTTP/2.13, which in
            #      turn is lower than HTTP/12.3;
            #   - Leading zeros MUST be ignored by recipients.
            if len(version_number) != 2:
                raise ValueError
            version_number = int(version_number[0]), int(version_number[1])
        except (ValueError, IndexError):
            self.send_error(
                HTTPStatus.BAD_REQUEST,
                "Bad request version (%r)" % version)
            return False
        if version_number >= (1, 1) and self.protocol_version >= "HTTP/1.1":
            self.close_connection = False
        if version_number >= (2, 0):
            self.send_error(
                HTTPStatus.HTTP_VERSION_NOT_SUPPORTED,
                "Invalid HTTP version (%s)" % base_version_number)
            return False
        self.request_version = version
    if not 2 <= len(words) <= 3:
        self.send_error(
            HTTPStatus.BAD_REQUEST,
            "Bad request syntax (%r)" % requestline)
        return False
    command, path = words[:2]
    if len(words) == 2:
        self.close_connection = True
        if command != 'GET':
            self.send_error(
                HTTPStatus.BAD_REQUEST,
                "Bad HTTP/0.9 request type (%r)" % command)
            return False
    self.command, self.path = command, path
    # Examine the headers and look for a Connection directive.
    try:
        self.headers = http.client.parse_headers(self.rfile,
                                                 _class=self.MessageClass)
    except http.client.LineTooLong as err:
        self.send_error(
            HTTPStatus.REQUEST_HEADER_FIELDS_TOO_LARGE,
            "Line too long",
            str(err))
        return False
    except http.client.HTTPException as err:
        self.send_error(
            HTTPStatus.REQUEST_HEADER_FIELDS_TOO_LARGE,
            "Too many headers",
            str(err)
        )
        return False
    conntype = self.headers.get('Connection', "")
    if conntype.lower() == 'close':
        self.close_connection = True
    elif (conntype.lower() == 'keep-alive' and
          self.protocol_version >= "HTTP/1.1"):
        self.close_connection = False
    # Examine the headers and look for an Expect directive
    expect = self.headers.get('Expect', "")
    if (expect.lower() == "100-continue" and
            self.protocol_version >= "HTTP/1.1" and
            self.request_version >= "HTTP/1.1"):
        if not self.handle_expect_100():
            return False
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.processCookies">
    <p>def <span class="ident">processCookies</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Read in cookies and extract the session id.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.processCookies', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.processCookies" class="source">
    <pre><code>def processCookies(self):
    '''
    Read in cookies and extract the session id.
    '''
    if self.server.useCookies:
        self.cookies = SimpleCookie(self.headers.get('Cookie'))
        if "UID" in self.cookies:
            self.uid = self.cookies["UID"]
        else:
            self.uid = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.reply">
    <p>def <span class="ident">reply</span>(</p><p>self, data, num=200)</p>
    </div>
    

    
  
    <div class="desc"><p>Reply to the client with the given status code. If data is given as a string
it will be encoded at utf8. Cookies are sent if they are used.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.reply', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.reply" class="source">
    <pre><code>def reply(self, data, num=200):
    '''
    Reply to the client with the given status code. If data is given as a string
    it will be encoded at utf8. Cookies are sent if they are used.
    '''
    self.send_response(num)
    if self.server.useCookies:
        self.send_header(
            "Set-Cookie", self.cookies.output(header='', sep=''))
    self.end_headers()
    if data is None:
        return
    if isinstance(data, str):
        data = data.encode("utf8")
    try:
        self.wfile.write(data)
        self.log_message("REPLY DONE")
    except Exception as ex:
        traceback.print_exc()
        self.server.log_error("Error sending: %s", str(ex))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.replyFile">
    <p>def <span class="ident">replyFile</span>(</p><p>self, path, num=200)</p>
    </div>
    

    
  
    <div class="desc"><p>Reply to client with given file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.replyFile', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.replyFile" class="source">
    <pre><code>def replyFile(self, path, num=200):
    '''
    Reply to client with given file.
    '''
    with open(path, "rb") as f:
        block = f.read()
        result = HtmlPage(block).html(self.uid)
        self.reply(result)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.send_error">
    <p>def <span class="ident">send_error</span>(</p><p>self, code, message=None, explain=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Send and log an error reply.</p>
<p>Arguments are
<em> code:    an HTTP error code
           3 digits
</em> message: a simple optional 1 line reason phrase.
           <em>( HTAB / SP / VCHAR / %x80-FF )
           defaults to short entry matching the response code
</em> explain: a detailed message defaults to the long entry
           matching the response code.</p>
<p>This sends an error response (so it must be called before any
output has been generated), logs the error, and finally sends
a piece of HTML explaining the error to the user.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.send_error', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.send_error" class="source">
    <pre><code>def send_error(self, code, message=None, explain=None):
    """Send and log an error reply.
    Arguments are
    * code:    an HTTP error code
               3 digits
    * message: a simple optional 1 line reason phrase.
               *( HTAB / SP / VCHAR / %x80-FF )
               defaults to short entry matching the response code
    * explain: a detailed message defaults to the long entry
               matching the response code.
    This sends an error response (so it must be called before any
    output has been generated), logs the error, and finally sends
    a piece of HTML explaining the error to the user.
    """
    try:
        shortmsg, longmsg = self.responses[code]
    except KeyError:
        shortmsg, longmsg = '???', '???'
    if message is None:
        message = shortmsg
    if explain is None:
        explain = longmsg
    self.log_error("code %d, message %s", code, message)
    self.send_response(code, message)
    self.send_header('Connection', 'close')
    # Message body is omitted for cases described in:
    #  - RFC7230: 3.3. 1xx, 204(No Content), 304(Not Modified)
    #  - RFC7231: 6.3.6. 205(Reset Content)
    body = None
    if (code >= 200 and
        code not in (HTTPStatus.NO_CONTENT,
                     HTTPStatus.RESET_CONTENT,
                     HTTPStatus.NOT_MODIFIED)):
        # HTML encode to prevent Cross Site Scripting attacks
        # (see bug #1100201)
        content = (self.error_message_format % {
            'code': code,
            'message': html.escape(message, quote=False),
            'explain': html.escape(explain, quote=False)
        })
        body = content.encode('UTF-8', 'replace')
        self.send_header("Content-Type", self.error_content_type)
        self.send_header('Content-Length', str(len(body)))
    self.end_headers()
    if self.command != 'HEAD' and body:
        self.wfile.write(body)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.send_head">
    <p>def <span class="ident">send_head</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Common code for GET and HEAD commands.</p>
<p>This sends the response code and MIME headers.</p>
<p>Return value is either a file object (which has to be copied
to the outputfile by the caller unless the command was HEAD,
and must be closed by the caller under all circumstances), or
None, in which case the caller has nothing further to do.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.send_head', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.send_head" class="source">
    <pre><code>def send_head(self):
    """Common code for GET and HEAD commands.
    This sends the response code and MIME headers.
    Return value is either a file object (which has to be copied
    to the outputfile by the caller unless the command was HEAD,
    and must be closed by the caller under all circumstances), or
    None, in which case the caller has nothing further to do.
    """
    path = self.translate_path(self.path)
    f = None
    if os.path.isdir(path):
        parts = urllib.parse.urlsplit(self.path)
        if not parts.path.endswith('/'):
            # redirect browser - doing basically what apache does
            self.send_response(HTTPStatus.MOVED_PERMANENTLY)
            new_parts = (parts[0], parts[1], parts[2] + '/',
                         parts[3], parts[4])
            new_url = urllib.parse.urlunsplit(new_parts)
            self.send_header("Location", new_url)
            self.end_headers()
            return None
        for index in "index.html", "index.htm":
            index = os.path.join(path, index)
            if os.path.exists(index):
                path = index
                break
        else:
            return self.list_directory(path)
    ctype = self.guess_type(path)
    # check for trailing "/" which should return 404. See Issue17324
    # The test for this was added in test_httpserver.py
    # However, some OS platforms accept a trailingSlash as a filename
    # See discussion on python-dev and Issue34711 regarding
    # parseing and rejection of filenames with a trailing slash
    if path.endswith("/"):
        self.send_error(HTTPStatus.NOT_FOUND, "File not found")
        return None
    try:
        f = open(path, 'rb')
    except OSError:
        self.send_error(HTTPStatus.NOT_FOUND, "File not found")
        return None
    try:
        fs = os.fstat(f.fileno())
        # Use browser cache if possible
        if ("If-Modified-Since" in self.headers
                and "If-None-Match" not in self.headers):
            # compare If-Modified-Since and time of last file modification
            try:
                ims = email.utils.parsedate_to_datetime(
                    self.headers["If-Modified-Since"])
            except (TypeError, IndexError, OverflowError, ValueError):
                # ignore ill-formed values
                pass
            else:
                if ims.tzinfo is None:
                    # obsolete format with no timezone, cf.
                    # https://tools.ietf.org/html/rfc7231#section-7.1.1.1
                    ims = ims.replace(tzinfo=datetime.timezone.utc)
                if ims.tzinfo is datetime.timezone.utc:
                    # compare to UTC datetime of last modification
                    last_modif = datetime.datetime.fromtimestamp(
                        fs.st_mtime, datetime.timezone.utc)
                    # remove microseconds, like in If-Modified-Since
                    last_modif = last_modif.replace(microsecond=0)
                    if last_modif <= ims:
                        self.send_response(HTTPStatus.NOT_MODIFIED)
                        self.end_headers()
                        f.close()
                        return None
        self.send_response(HTTPStatus.OK)
        self.send_header("Content-type", ctype)
        self.send_header("Content-Length", str(fs[6]))
        self.send_header("Last-Modified",
            self.date_time_string(fs.st_mtime))
        self.end_headers()
        return f
    except:
        f.close()
        raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.send_header">
    <p>def <span class="ident">send_header</span>(</p><p>self, keyword, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Send a MIME header to the headers buffer.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.send_header', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.send_header" class="source">
    <pre><code>def send_header(self, keyword, value):
    """Send a MIME header to the headers buffer."""
    if self.request_version != 'HTTP/0.9':
        if not hasattr(self, '_headers_buffer'):
            self._headers_buffer = []
        self._headers_buffer.append(
            ("%s: %s\r\n" % (keyword, value)).encode('latin-1', 'strict'))
    if keyword.lower() == 'connection':
        if value.lower() == 'close':
            self.close_connection = True
        elif value.lower() == 'keep-alive':
            self.close_connection = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.send_response">
    <p>def <span class="ident">send_response</span>(</p><p>self, code, message=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Add the response header to the headers buffer and log the
response code.</p>
<p>Also send two standard headers with the server software
version and the current date.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.send_response', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.send_response" class="source">
    <pre><code>def send_response(self, code, message=None):
    """Add the response header to the headers buffer and log the
    response code.
    Also send two standard headers with the server software
    version and the current date.
    """
    self.log_request(code)
    self.send_response_only(code, message)
    self.send_header('Server', self.version_string())
    self.send_header('Date', self.date_time_string())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.send_response_only">
    <p>def <span class="ident">send_response_only</span>(</p><p>self, code, message=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Send the response header only.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.send_response_only', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.send_response_only" class="source">
    <pre><code>def send_response_only(self, code, message=None):
    """Send the response header only."""
    if self.request_version != 'HTTP/0.9':
        if message is None:
            if code in self.responses:
                message = self.responses[code][0]
            else:
                message = ''
        if not hasattr(self, '_headers_buffer'):
            self._headers_buffer = []
        self._headers_buffer.append(("%s %d %s\r\n" %
                (self.protocol_version, code, message)).encode(
                    'latin-1', 'strict'))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.setup">
    <p>def <span class="ident">setup</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.setup', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.setup" class="source">
    <pre><code>def setup(self):
    self.connection = self.request
    if self.timeout is not None:
        self.connection.settimeout(self.timeout)
    if self.disable_nagle_algorithm:
        self.connection.setsockopt(socket.IPPROTO_TCP,
                                   socket.TCP_NODELAY, True)
    self.rfile = self.connection.makefile('rb', self.rbufsize)
    if self.wbufsize == 0:
        self.wfile = _SocketWriter(self.connection)
    else:
        self.wfile = self.connection.makefile('wb', self.wbufsize)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.translate_path">
    <p>def <span class="ident">translate_path</span>(</p><p>self, path)</p>
    </div>
    

    
  
    <div class="desc"><p>Translate a /-separated PATH to the local filename syntax.</p>
<p>Components that mean special things to the local file system
(e.g. drive or directory names) are ignored.  (XXX They should
probably be diagnosed.)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.translate_path', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.translate_path" class="source">
    <pre><code>def translate_path(self, path):
    """Translate a /-separated PATH to the local filename syntax.
    Components that mean special things to the local file system
    (e.g. drive or directory names) are ignored.  (XXX They should
    probably be diagnosed.)
    """
    # abandon query parameters
    path = path.split('?',1)[0]
    path = path.split('#',1)[0]
    # Don't forget explicit trailing slash when normalizing. Issue17324
    trailing_slash = path.rstrip().endswith('/')
    try:
        path = urllib.parse.unquote(path, errors='surrogatepass')
    except UnicodeDecodeError:
        path = urllib.parse.unquote(path)
    path = posixpath.normpath(path)
    words = path.split('/')
    words = filter(None, words)
    path = self.directory
    for word in words:
        if os.path.dirname(word) or word in (os.curdir, os.pardir):
            # Ignore components that are not a simple file/directory name
            continue
        path = os.path.join(path, word)
    if trailing_slash:
        path += '/'
    return path
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Handler.version_string">
    <p>def <span class="ident">version_string</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the server software version string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Handler.version_string', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Handler.version_string" class="source">
    <pre><code>def version_string(self):
    """Return the server software version string."""
    return self.server_version + ' ' + self.sys_version
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.HtmlPage" class="name">class <span class="ident">HtmlPage</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage" class="source">
    <pre><code>class HtmlPage:
    # Patterns for matching HTML to figure out where to inject the javascript code
    _pscript = re.compile(
        b'\\<script.*\\s+src\\s*=\\s*"appscript.js"')
    _plist = [re.compile(b'\\{\\{JSCRIPT\\}\\}', re.IGNORECASE),
        re.compile(b'\\<script\\>', re.IGNORECASE),
        re.compile(b'\\<\\/head\\>', re.IGNORECASE),
        re.compile(b'\\<body\\>', re.IGNORECASE),
        re.compile(b'\\<html\\>', re.IGNORECASE)]

    pageMap = {}
    pageActive = {}
    # pageThread = {}
                       
    def __init__(self, html=None, file=None):
        if file:
            with open(file, "rb") as f:
                self.result = f.read()
        elif html:
            if isinstance(html, bytes):
                self.result = html
            else:
                self.result = html.encode("utf8")
        else:
            self.result = None
        self.pageid = uuid.uuid1().hex

    def alive(self):
        return self.pageid in self.pageActive

    @classmethod
    def expire(cls, item=None):
        if item:
            del cls.pageActive[item]
            del cls.pageMap[item]
            
        old = time.time() - 5
        remove = []
        for k,v in cls.pageActive.items():
            if v < old:
                remove.append(k)
        for k in remove:
            del cls.pageActive[k]
            del cls.pageMap[k]

    def html(self, uid):
        '''
        Once the page has been loaded, this will return the appropriate
        HTML for the uid given.
        '''
        return self.insertJS(uid, self.result)

    def insertJS(self, uid, html):
        '''
        Insert the Javascript library into HTML. The strategy is that it will look for patterns
        to figure out where to insert. If "<script src="appjscript.js">" is found, it will not
        make changes and will return the Javascript when the browser requests the appjscript.js
        file. Otherwise, it will insert it into a <script> section, the <head> or at the start
        of the HTML. In any case, this function will insert the global variable UID containing
        the session id.
        '''
        self.pageMap[self.pageid] = uid
        # self.pageThread[self.pageid] = threading.get_ident()
        self.pageActive[self.pageid] = time.time()

        U = "var UID='{}';var PAGEID='{}';\n".format(uid, self.pageid).encode("utf8")
        m = self._pscript.search(html)
        if m:
            sx, ex = m.span()
            return html[:sx] + b"<script>"+U+b"</script>" + html[sx:]
        for i, p in enumerate(self._plist):
            m = p.search(html)
            if m:
                sx, ex = m.span()
                if i == 0:
                    return html[:sx] + U + JSCRIPT + html[ex:]
                elif i == 1:
                    return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
                elif i == 2:
                    return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
                else:
                    return html[:sx] + b"<head><script>" + U + JSCRIPT + b"</script></head>" + html
        return b"<head><script>" + U + JSCRIPT + b"</script></head>" + html
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.HtmlPage">HtmlPage</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="jyserver.HtmlPage.pageActive" class="name">var <span class="ident">pageActive</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.HtmlPage.pageMap" class="name">var <span class="ident">pageMap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.HtmlPage.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, html=None, file=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage.__init__" class="source">
    <pre><code>def __init__(self, html=None, file=None):
    if file:
        with open(file, "rb") as f:
            self.result = f.read()
    elif html:
        if isinstance(html, bytes):
            self.result = html
        else:
            self.result = html.encode("utf8")
    else:
        self.result = None
    self.pageid = uuid.uuid1().hex
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.HtmlPage.alive">
    <p>def <span class="ident">alive</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage.alive', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage.alive" class="source">
    <pre><code>def alive(self):
    return self.pageid in self.pageActive
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.HtmlPage.html">
    <p>def <span class="ident">html</span>(</p><p>self, uid)</p>
    </div>
    

    
  
    <div class="desc"><p>Once the page has been loaded, this will return the appropriate
HTML for the uid given.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage.html', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage.html" class="source">
    <pre><code>def html(self, uid):
    '''
    Once the page has been loaded, this will return the appropriate
    HTML for the uid given.
    '''
    return self.insertJS(uid, self.result)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.HtmlPage.insertJS">
    <p>def <span class="ident">insertJS</span>(</p><p>self, uid, html)</p>
    </div>
    

    
  
    <div class="desc"><p>Insert the Javascript library into HTML. The strategy is that it will look for patterns
to figure out where to insert. If "<script src="appjscript.js">" is found, it will not
make changes and will return the Javascript when the browser requests the appjscript.js
file. Otherwise, it will insert it into a <script> section, the <head> or at the start
of the HTML. In any case, this function will insert the global variable UID containing
the session id.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage.insertJS', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage.insertJS" class="source">
    <pre><code>def insertJS(self, uid, html):
    '''
    Insert the Javascript library into HTML. The strategy is that it will look for patterns
    to figure out where to insert. If "<script src="appjscript.js">" is found, it will not
    make changes and will return the Javascript when the browser requests the appjscript.js
    file. Otherwise, it will insert it into a <script> section, the <head> or at the start
    of the HTML. In any case, this function will insert the global variable UID containing
    the session id.
    '''
    self.pageMap[self.pageid] = uid
    # self.pageThread[self.pageid] = threading.get_ident()
    self.pageActive[self.pageid] = time.time()
    U = "var UID='{}';var PAGEID='{}';\n".format(uid, self.pageid).encode("utf8")
    m = self._pscript.search(html)
    if m:
        sx, ex = m.span()
        return html[:sx] + b"<script>"+U+b"</script>" + html[sx:]
    for i, p in enumerate(self._plist):
        m = p.search(html)
        if m:
            sx, ex = m.span()
            if i == 0:
                return html[:sx] + U + JSCRIPT + html[ex:]
            elif i == 1:
                return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
            elif i == 2:
                return html[:sx] + b"<script>" + U + JSCRIPT + b"</script>" + html[sx:]
            else:
                return html[:sx] + b"<head><script>" + U + JSCRIPT + b"</script></head>" + html
    return b"<head><script>" + U + JSCRIPT + b"</script></head>" + html
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.HtmlPage.pageid" class="name">var <span class="ident">pageid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.HtmlPage.expire">
    <p>def <span class="ident">expire</span>(</p><p>cls, item=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.HtmlPage.expire', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.HtmlPage.expire" class="source">
    <pre><code>@classmethod
def expire(cls, item=None):
    if item:
        del cls.pageActive[item]
        del cls.pageMap[item]
        
    old = time.time() - 5
    remove = []
    for k,v in cls.pageActive.items():
        if v < old:
            remove.append(k)
    for k in remove:
        del cls.pageActive[k]
        del cls.pageMap[k]
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.JSchain" class="name">class <span class="ident">JSchain</span></p>
      
  
    <div class="desc"><p>JSchain keeps track of the dynamically generated Javascript. It
tracks names, data item accesses and function calls. JSchain
is usually not used directly, but accessed through the JS class.</p>
<h2>Attributes</h2>
<p>state
    A JSstate instance. This instance should be the same
    for all call of the same session.</p>
<h2>Notes</h2>
<p>There is a special name called <code>dom</code> which is shorthand for
lookups. For example,</p>
<pre><code>js.dom.button1.innerHTML
</code></pre>
<p>Becomes</p>
<pre><code>js.document.getElementById("button1").innerHTML
</code></pre>
<h2>Example</h2>
<p><code>state = JSstate(server)
js = JSchain(state)
js.document.getElementById("txt").value</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain" class="source">
    <pre><code>class JSchain:
    '''
    JSchain keeps track of the dynamically generated Javascript. It
    tracks names, data item accesses and function calls. JSchain
    is usually not used directly, but accessed through the JS class.

    Attributes
    -----------
    state
        A JSstate instance. This instance should be the same
        for all call of the same session.
        
    Notes
    -----------
    There is a special name called `dom` which is shorthand for
    lookups. For example,

        js.dom.button1.innerHTML

    Becomes

        js.document.getElementById("button1").innerHTML

    Example
    --------------
    ```
    state = JSstate(server)
    js = JSchain(state)
    js.document.getElementById("txt").value
    ```
    '''

    def __init__(self, state):
        self.state = state
        self.chain = []
        self.keep = True

    def _dup(self):
        '''
        Duplicate this chain for processing.
        '''
        js = JSchain(self.state)
        js.chain = self.chain.copy()  # [x[:] for x in self.chain]
        return js

    def _add(self, attr, dot=True):
        '''
        Add item to the chain. If `dot` is True, then a dot is added. If
        not, this is probably a function call and not dot should be added.
        '''
        if not attr:
            # this happens when __setattr__ is called when the first
            # item of a JSchain is an assignment
            return self
        if dot and len(self.chain) > 0:
            self.chain.append(".")
        self.chain.append(attr)
        return self

    def _prepend(self, attr):
        '''
        Add item to the start of the chain. 
        '''
        self.chain.insert(0, attr)
        return self

    def _last(self):
        '''
        Last item on the chain.
        '''
        return self.chain[-1]

    def __getattr__(self, attr):
        '''
        Called to process items in a dot chain in Python syntax. For example,
        in a.b.c, this will get called for "b" and "c".
        '''
        # __iter__ calls should be ignored
        if attr == "__iter__":
            return self
        return self.getdata(attr)

    def getdata(self, attr, adot=True):
        if self._last() == 'dom':
            # substitute the `dom` shortcut
            self.chain[-1] = 'document'
            self._add('getElementById')
            self._add('("{}")'.format(attr), dot=False)
        else:
            # add the item to the chain
            self._add(attr, dot=adot)
        return self

    def __setattr__(self, attr, value):
        value = JSroot._v(value)
        if attr == "chain" or attr == "state" or attr == "keep":
            # ignore our own attributes. If an attribute is added to "self" it
            # should be added here. I suppose this could be evaluated dynamically
            # using the __dict__ member.
            super(JSchain, self).__setattr__(attr, value)
            return value
        # print("SET", attr, value)
        self.setdata(attr, value)
        self.execExpression()

    def setdata(self, attr, value, adot=True):
        '''
        Called during assigment, as in `self.js.x = 10` or during a call
        assignement as in `self.js.onclick = func`, where func is a function.
        '''
        if callable(value):
            # is this a function call?
            idx = id(value)
            self.state.fxn[idx] = value
            self._add(attr, dot=adot)
            self._add("=function(){{server._callfxn(%s);}}" % idx, dot=False)
        else:
            # otherwise, regular assignment
            self._add(attr, dot=adot)
            self._add("=" + json.dumps(value), dot=False)
        return value

    def __setitem__(self, key, value):
        jkey = "['%s']" % str(key)
        self.setdata(jkey, value, adot=False)
        self.execExpression()
        return value

    def __getitem__(self, key):
        # all keys are strings in json, so format it
        key = str(key)
        c = self._dup()
        c._prepend("'%s' in " % key)
        haskey = c.eval()
        if not haskey:
            raise KeyError(key)
        jkey = "['%s']" % key
        c = self.getdata(jkey, adot=False)
        return c.eval()

    def __call__(self, *args, **kwargs):
        '''
        Called when we are using in a functiion context, as in
        `self.js.func(15)`.
        '''
        # evaluate the arguments
        p1 = [json.dumps(JSroot._v(v)) for v in args]
        p2 = [json.dumps(JSroot._v(v)) for k, v in kwargs.items()]
        s = ','.join(p1 + p2)
        # create the function call
        self._add('('+s+')', dot=False)
        return self

    def _statement(self):
        '''
        Join all the elements and return a string representation of the
        Javascript expression.
        '''
        return ''.join(self.chain)

    def __bytes__(self):
        '''
        Join the elements and return as bytes encode in utf8 suitable for
        sending back to the browser.
        '''
        return (''.join(self.chain)).encode("utf8")

    def evalAsync(self):
        if self.keep:
            stmt = self._statement()
            self.state.addTask(stmt)
            # mark it as evaluated
            self.keep = False

    def __del__(self):
        '''
        Execute the statment when the object is deleted.

        An object is deleted when it goes out of scope. That's when it is put
        together and sent to the browser for execution. 

        For statements,
        this happens when the statement ends. For example,

           self.js.func(1)

        goes out of scope when the statement after func(1). However,

           v = self.js.myvalue

        goes out of scope when the "v" goes out of scope, usually at then end of
        the function where it was used. In this case, the Javascript will be
        evaluated when "v" itself is evaluated. This happens when you perform
        an operation such as "v+5", saving or printing.

        "v" in the example above is assigned an object and not a value. This
        means that every time it is evaluated in an expression, it goes back 
        to the server and retrieves the current value.

        On the other hand,

           self.v = self.js.myvalue

        will probably never go out of scope because it is tied to the class.
        To force an evaluation, call the "eval()"
        method, as in "self.js.myvalue.eval()".
        '''
        if not self.keep: return
        # print("!!!DEL!!!")
        try:
            self.execExpression()
        except Exception as ex:
            self.state._error = ex
            self.state._server.log_error("Uncatchable exception: %s", str(ex))
            raise ex

    def execExpression(self):
        # Is this a temporary expression that cannot evaluated?
        if self.keep:
            stmt = self._statement()
            # print("EXEC", stmt)
            if self.state.lock.locked():
                # print("ASYNC", stmt)
                # running within a query, so just run it async
                self._addTask(stmt)
            else:
                # otherwise, wait for evaluation
                # print("SYNC", stmt)
                try:
                    self.eval()
                except Exception as ex:
                    self.keep = False
                    raise ex
            # mark it as evaluated
            self.keep = False

    def eval(self, timeout=10):
        '''
        Evaluate this object by converting it to Javascript, sending it to the browser
        and waiting for a response. This function is automatically called when the object
        is used in operators or goes out of scope so it rarely needs to
        be called directly.

        However, it is helpful
        to occasionally call this to avoid out-of-order results. For example,

            v = self.js.var1
            self.js.var1 = 10
            print(v)

        This will print the value 10, regardless of what var1 was before the assignment.
        That is because "v" is the abstract statemnt, not the evaluated value. 
        The assigment "var1=10" is evaluated immediately. However,
        "v" is evaluated by the Browser 
        when "v" is converted to a string in the print statement. If this is a problem,
        the code should be changed to:

            v = self.js.var1.eval()
            self.js.var1 = 10
            print(v)

        In that case, "v" is resolved immediately and hold the value of var1 before the
        assignment.

        Attributes
        -------------
        timeout
            Time to wait in seconds before giving up if no response is received.
        '''
        if not self.keep:
            return 0
            # raise ValueError("Expression cannot be evaluated")
        else:
            self.keep = False

        stmt = self._statement()
        # print("EVAL", stmt)

        c = self.state

        if c.lock.locked():
            c.log_error("App is active so you cannot manipulate JS for: %s" % stmt)
            raise RuntimeError("App is active so you cannot manipulate JS for: %s" % stmt)

        idx, q = c.addQuery()
        data = json.dumps(stmt)
        cmd = "sendFromBrowserToServer({}, {})".format(data, idx)
        c.addTask(cmd)
        try:
            c.log_message("WAITING ON RESULT QUEUE")
            result = q.get(timeout=timeout)
            c.delQuery(idx)
        except queue.Empty:
            # self.state._server.log_message("TIMEOUT waiting on: %s", stmt)
            raise TimeoutError("Timout waiting on: %s" % stmt)
        if result["error"] != "":
            # self.state._server.log_error("ERROR EVAL %s : %s", result["error"], stmt)
            raise RuntimeError(result["error"] + ": " + stmt)
        if "value" in result:
            return result["value"]
        else:
            return 0

    #
    # Magic methods. We create these methods for force the
    # Javascript to be evaluated if it is used in any
    # opreation.
    #
    def __cmp__(self, other): return self.eval().__cmp__(other)
    def __eq__(self, other): return self.eval().__eq__(other)
    def __ne__(self, other): return self.eval().__ne__(other)
    def __gt__(self, other): return self.eval().__gt__(other)
    def __lt__(self, other): return self.eval().__lt__(other)
    def __ge__(self, other): return self.eval().__ge__(other)
    def __le__(self, other): return self.eval().__le__(other)

    def __pos__(self): return self.eval().__pos__()
    def __neg__(self): return self.eval().__neg__()
    def __abs__(self): return self.eval().__abs__()
    def __invert__(self): return self.eval().__invert__()
    def __round__(self, n): return self.eval().__round__(n)
    def __floor__(self): return self.eval().__floor__()
    def __ceil__(self): return self.eval().__ceil__()
    def __trunc__(self): return self.eval().__trunc__()

    def __add__(self, other): return self.eval().__add__(other)
    def __and__(self, other): return self.eval().__and__(other)
    def __div__(self, other): return self.eval().__div__(other)
    def __divmod__(self, other): return self.eval().__divmod__(other)
    def __floordiv__(self, other): return self.eval().__floordiv__(other)
    def __lshift__(self, other): return self.eval().__lshift__(other)
    def __mod__(self, other): return self.eval().__mod__(other)
    def __mul__(self, other): return self.eval().__mul__(other)
    def __or__(self, other): return self.eval().__or__(other)
    def __pow__(self, other): return self.eval().__pow__(other)
    def __rshift__(self, other): return self.eval().__rshift__(other)
    def __sub__(self, other): return self.eval().__sub__(other)
    def __truediv__(self, other): return self.eval().__truediv__(other)
    def __xor__(self, other): return self.eval().__xor__(other)

    def __radd__(self, other): return self.eval().__radd__(other)
    def __rand__(self, other): return self.eval().__rand__(other)
    def __rdiv__(self, other): return self.eval().__rdiv__(other)
    def __rdivmod__(self, other): return self.eval().__rdivmod__(other)
    def __rfloordiv__(self, other): return self.eval().__rfloordiv__(other)
    def __rlshift__(self, other): return self.eval().__rlshift__(other)
    def __rmod__(self, other): return self.eval().__rmod__(other)
    def __rmul__(self, other): return self.eval().__rmul__(other)
    def __ror__(self, other): return self.eval().__ror__(other)
    def __rpow__(self, other): return self.eval().__rpow__(other)
    def __rrshift__(self, other): return self.eval().__rrshift__(other)
    def __rsub__(self, other): return self.eval().__rsub__(other)
    def __rtruediv__(self, other): return self.eval().__rtruediv__(other)
    def __rxor__(self, other): return self.eval().__rxor__(other)

    def __coerce__(self, other): return self.eval().__coerce__(other)
    def __complex__(self): return self.eval().__complex__()
    def __float__(self): return self.eval().__float__()
    def __hex__(self): return self.eval().__hex__()
    def __index__(self): return self.eval().__index__()
    def __int__(self): return self.eval().__int__()
    def __long__(self): return self.eval().__long__()
    def __oct__(self): return self.eval().__oct__()
    def __str__(self): return self.eval().__str__()
    def __dir__(self): return self.eval().__dir__()
    def __format__(self, formatstr): return self.eval().__format__(formatstr)
    def __hash__(self): return self.eval().__hash__()
    def __nonzero__(self): return self.eval().__nonzero__()
    def __repr__(self): return self.eval().__repr__()
    def __sizeof__(self): return self.eval().__sizeof__()
    def __unicode__(self): return self.eval().__unicode__()

    def __iter__(self): return self.eval().__iter__()
    def __reversed__(self): return self.eval().__reversed__()
    def __contains__(self, item): 
        d = self.eval()
        if isinstance(d, dict):
            # json makes all keys strings
            return d.__contains__(str(item))
        else:
            return d.__contains__(item)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.JSchain">JSchain</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, state)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.__init__" class="source">
    <pre><code>def __init__(self, state):
    self.state = state
    self.chain = []
    self.keep = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.eval">
    <p>def <span class="ident">eval</span>(</p><p>self, timeout=10)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluate this object by converting it to Javascript, sending it to the browser
and waiting for a response. This function is automatically called when the object
is used in operators or goes out of scope so it rarely needs to
be called directly.</p>
<p>However, it is helpful
to occasionally call this to avoid out-of-order results. For example,</p>
<pre><code>v = self.js.var1
self.js.var1 = 10
print(v)
</code></pre>
<p>This will print the value 10, regardless of what var1 was before the assignment.
That is because "v" is the abstract statemnt, not the evaluated value. 
The assigment "var1=10" is evaluated immediately. However,
"v" is evaluated by the Browser 
when "v" is converted to a string in the print statement. If this is a problem,
the code should be changed to:</p>
<pre><code>v = self.js.var1.eval()
self.js.var1 = 10
print(v)
</code></pre>
<p>In that case, "v" is resolved immediately and hold the value of var1 before the
assignment.</p>
<h2>Attributes</h2>
<p>timeout
    Time to wait in seconds before giving up if no response is received.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.eval', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.eval" class="source">
    <pre><code>def eval(self, timeout=10):
    '''
    Evaluate this object by converting it to Javascript, sending it to the browser
    and waiting for a response. This function is automatically called when the object
    is used in operators or goes out of scope so it rarely needs to
    be called directly.
    However, it is helpful
    to occasionally call this to avoid out-of-order results. For example,
        v = self.js.var1
        self.js.var1 = 10
        print(v)
    This will print the value 10, regardless of what var1 was before the assignment.
    That is because "v" is the abstract statemnt, not the evaluated value. 
    The assigment "var1=10" is evaluated immediately. However,
    "v" is evaluated by the Browser 
    when "v" is converted to a string in the print statement. If this is a problem,
    the code should be changed to:
        v = self.js.var1.eval()
        self.js.var1 = 10
        print(v)
    In that case, "v" is resolved immediately and hold the value of var1 before the
    assignment.
    Attributes
    -------------
    timeout
        Time to wait in seconds before giving up if no response is received.
    '''
    if not self.keep:
        return 0
        # raise ValueError("Expression cannot be evaluated")
    else:
        self.keep = False
    stmt = self._statement()
    # print("EVAL", stmt)
    c = self.state
    if c.lock.locked():
        c.log_error("App is active so you cannot manipulate JS for: %s" % stmt)
        raise RuntimeError("App is active so you cannot manipulate JS for: %s" % stmt)
    idx, q = c.addQuery()
    data = json.dumps(stmt)
    cmd = "sendFromBrowserToServer({}, {})".format(data, idx)
    c.addTask(cmd)
    try:
        c.log_message("WAITING ON RESULT QUEUE")
        result = q.get(timeout=timeout)
        c.delQuery(idx)
    except queue.Empty:
        # self.state._server.log_message("TIMEOUT waiting on: %s", stmt)
        raise TimeoutError("Timout waiting on: %s" % stmt)
    if result["error"] != "":
        # self.state._server.log_error("ERROR EVAL %s : %s", result["error"], stmt)
        raise RuntimeError(result["error"] + ": " + stmt)
    if "value" in result:
        return result["value"]
    else:
        return 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.evalAsync">
    <p>def <span class="ident">evalAsync</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.evalAsync', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.evalAsync" class="source">
    <pre><code>def evalAsync(self):
    if self.keep:
        stmt = self._statement()
        self.state.addTask(stmt)
        # mark it as evaluated
        self.keep = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.execExpression">
    <p>def <span class="ident">execExpression</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.execExpression', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.execExpression" class="source">
    <pre><code>def execExpression(self):
    # Is this a temporary expression that cannot evaluated?
    if self.keep:
        stmt = self._statement()
        # print("EXEC", stmt)
        if self.state.lock.locked():
            # print("ASYNC", stmt)
            # running within a query, so just run it async
            self._addTask(stmt)
        else:
            # otherwise, wait for evaluation
            # print("SYNC", stmt)
            try:
                self.eval()
            except Exception as ex:
                self.keep = False
                raise ex
        # mark it as evaluated
        self.keep = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.getdata">
    <p>def <span class="ident">getdata</span>(</p><p>self, attr, adot=True)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.getdata', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.getdata" class="source">
    <pre><code>def getdata(self, attr, adot=True):
    if self._last() == 'dom':
        # substitute the `dom` shortcut
        self.chain[-1] = 'document'
        self._add('getElementById')
        self._add('("{}")'.format(attr), dot=False)
    else:
        # add the item to the chain
        self._add(attr, dot=adot)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSchain.setdata">
    <p>def <span class="ident">setdata</span>(</p><p>self, attr, value, adot=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Called during assigment, as in <code>self.js.x = 10</code> or during a call
assignement as in <code>self.js.onclick = func</code>, where func is a function.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSchain.setdata', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSchain.setdata" class="source">
    <pre><code>def setdata(self, attr, value, adot=True):
    '''
    Called during assigment, as in `self.js.x = 10` or during a call
    assignement as in `self.js.onclick = func`, where func is a function.
    '''
    if callable(value):
        # is this a function call?
        idx = id(value)
        self.state.fxn[idx] = value
        self._add(attr, dot=adot)
        self._add("=function(){{server._callfxn(%s);}}" % idx, dot=False)
    else:
        # otherwise, regular assignment
        self._add(attr, dot=adot)
        self._add("=" + json.dumps(value), dot=False)
    return value
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.JSchain.chain" class="name">var <span class="ident">chain</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.JSchain.keep" class="name">var <span class="ident">keep</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.JSchain.state" class="name">var <span class="ident">state</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.JSroot" class="name">class <span class="ident">JSroot</span></p>
      
  
    <div class="desc"><p>JS handles the lifespan of JSchain objects and things like setting
and evaluation on the root object.</p>
<h2>Example:</h2>
<p><code>state = ClientContext(AppClass)
js = JSroot(state)
js.document.getElementById("txt").value = 25</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSroot', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSroot" class="source">
    <pre><code>class JSroot:
    '''
    JS handles the lifespan of JSchain objects and things like setting
    and evaluation on the root object.

    Example:
    --------------
    ```
    state = ClientContext(AppClass)
    js = JSroot(state)
    js.document.getElementById("txt").value = 25
    ```
    '''

    def __init__(self, state):
        # state is a JSstate instance unique for each session
        self.state = state
        # keep track of assignments
        self.linkset = {}
        # keep track of calls
        self.linkcall = {}

    @staticmethod
    def _v(value):
        '''
        If `value` is a JSchain, evaluate it. Otherwise, return value.
        '''
        if isinstance(value, JSchain):
            return value.eval()
        else:
            return value

    def __getattr__(self, attr):
        '''
        Called when using "." operator for the first time. Create a new chain and use it.
        Subsequent "." operators get processed by JSchain.
        '''
        # rasise any pending errors; these errors can get
        # generate on __del__() or other places that Python
        # will ignore.
        if self.state._error:
            e = self.state._error
            self.state._error = None
            raise e

        chain = JSchain(self.state)
        chain._add(attr)
        return chain

    def __setattr__(self, attr, value):
        '''
        Called when assiging attributes. This means no JSchain was created, so just process
        it directly.
        '''
        # if the value to be assigned is itself a JSchain, evaluate it
        value = JSroot._v(value)
        # don't process our own attributes
        if attr == "state" or attr == "linkset" or attr == "linkcall":
            super(JSroot, self).__setattr__(attr, value)
            return value
        # create a new JSchain
        c = self.__getattr__(attr)
        c.__setattr__(None, value)
        # c._add("=" + json.dumps(value), dot=False)
        return c

    def __getitem__(self, key):
        # this should never be called
        pass

    def __setitem__(self, key, value):
        value = JSroot._v(value)
        if key in self.linkcall:
            c = self.linkcall[key]
            if isinstance(c, JSchain):
                js = c._dup()
                if isinstance(value, list) or isinstance(value, tuple):
                    js.__call__(*value)
                else:
                    js.__call__(value)
            elif callable(c):
                c(value)
        elif key in self.linkset:
            c = self.linkset[key]
            if isinstance(c, JSchain):
                js = c._dup()
                js._add("=" + json.dumps(value), dot=False)

    def eval(self, stmt):
        '''
        Evaluate a Javascript statement `stmt` in on the Browser.
        '''
        chain = JSchain(self.state)
        chain._add(stmt)
        return chain.eval()

    def val(self, key, callback):
        self.linkset[key] = callback
        callback.keep = False

    def call(self, key, callback):
        self.linkcall[key] = callback
        if isinstance(callback, JSchain):
            callback.keep = False

    def __enter__(self):
        '''
        For use in "with" statements, as in:
            with server.js() as js:
                js.runme()
        '''
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.JSroot">JSroot</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.JSroot.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, state)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSroot.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSroot.__init__" class="source">
    <pre><code>def __init__(self, state):
    # state is a JSstate instance unique for each session
    self.state = state
    # keep track of assignments
    self.linkset = {}
    # keep track of calls
    self.linkcall = {}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSroot.call">
    <p>def <span class="ident">call</span>(</p><p>self, key, callback)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSroot.call', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSroot.call" class="source">
    <pre><code>def call(self, key, callback):
    self.linkcall[key] = callback
    if isinstance(callback, JSchain):
        callback.keep = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSroot.eval">
    <p>def <span class="ident">eval</span>(</p><p>self, stmt)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluate a Javascript statement <code>stmt</code> in on the Browser.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSroot.eval', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSroot.eval" class="source">
    <pre><code>def eval(self, stmt):
    '''
    Evaluate a Javascript statement `stmt` in on the Browser.
    '''
    chain = JSchain(self.state)
    chain._add(stmt)
    return chain.eval()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.JSroot.val">
    <p>def <span class="ident">val</span>(</p><p>self, key, callback)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.JSroot.val', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.JSroot.val" class="source">
    <pre><code>def val(self, key, callback):
    self.linkset[key] = callback
    callback.keep = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.JSroot.linkcall" class="name">var <span class="ident">linkcall</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.JSroot.linkset" class="name">var <span class="ident">linkset</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.JSroot.state" class="name">var <span class="ident">state</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.Server" class="name">class <span class="ident">Server</span></p>
      
  
    <div class="desc"><p>Server implements the web server, waits for connections and processes
commands. Each browser request is handled in its own thread and so requests
are asynchronous. The server starts listening when the "start()" method is
called.</p>
<h2>Methods</h2>
<p>start(wait, cookies)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server" class="source">
    <pre><code>class Server(ThreadingTCPServer):
    '''
    Server implements the web server, waits for connections and processes
    commands. Each browser request is handled in its own thread and so requests
    are asynchronous. The server starts listening when the "start()" method is
    called.

    Methods
    ------------
    start(wait, cookies)
    '''

    PORT = 8080
    allow_reuse_address = True

    def __init__(self, appClass, port=PORT, ip=None, verbose=False):
        '''
        Parameters
        -------------
        appClass
            Class that inherits Client. Note that this is the
            class name and not an instance.
        port
            Port to listen to (default is PORT)
        ip
            IP address to bind (default is all)
        '''
        self.verbose = verbose
        # Instantiate objects of this class; must inherit from Client
        self.appClass = appClass
        self.contextMap = {}
        # The port number
        self.port = port
        if ip is None:
            ip = '127.0.0.1'
        # Create the server object. Must call start() to begin listening.
        super(Server, self).__init__((ip, port), Handler)

    # def getContext(self):
    #     return self._getContextForPage('SINGLE')

    def js(self):
        '''
        If you are implementing a single application without a "main"
        function, you can call this to retrieve the JS object and set
        up for single instance execution.
        '''
        return self._getContextForPage('SINGLE', True).getJS()

    def _getContextForPage(self, uid, create = False):
        c = ClientContext._getContextForPage(uid, self.appClass, create=create, verbose=self.verbose)
        return c
        
    def stop(self):
        # self._BaseServer__shutdown_request = True
        self._runmode = False
        # self.shutdown()

    def _runServer(self):
        '''
        Begin running the server until terminated.
        '''
        self._runmode = True
        while self._runmode:
            self.handle_request()
        # self.serve_forever()
        self.log_message("SERVER TERMINATED")

    def start(self, wait=True, cookies=True):
        '''
        Start listening to the port and processing requests.

        Parameters
        ------------
        wait
            Start listening and wait for server to terminate. If this
            is false, start server on new thread and continue execution.
        cookies
            If True, try to use cookies to keep track of sessions. This
            enables the browser to open multiple windows that all share
            the same Client object. If False, then cookies are disabled
            and each tab will be it's own session.
        '''
        self.useCookies = cookies
        if wait or hasattr(self.appClass, "main"):
            self._runServer()
        else:
            server_thread = threading.Thread(target=self._runServer, daemon=True)
            server_thread.start()

    def log_message(self, format, *args):
        if self.verbose:
            print(format % args)
    def log_error(self, format, *args):
        print(format % args)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.Server">Server</a></li>
          <li>socketserver.ThreadingTCPServer</li>
          <li>socketserver.ThreadingMixIn</li>
          <li>socketserver.TCPServer</li>
          <li>socketserver.BaseServer</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="jyserver.Server.PORT" class="name">var <span class="ident">PORT</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.address_family" class="name">var <span class="ident">address_family</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.allow_reuse_address" class="name">var <span class="ident">allow_reuse_address</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.block_on_close" class="name">var <span class="ident">block_on_close</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.daemon_threads" class="name">var <span class="ident">daemon_threads</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.request_queue_size" class="name">var <span class="ident">request_queue_size</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.socket_type" class="name">var <span class="ident">socket_type</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.timeout" class="name">var <span class="ident">timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.Server.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, appClass, port=8080, ip=None, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><h2>Parameters</h2>
<p>appClass
    Class that inherits Client. Note that this is the
    class name and not an instance.
port
    Port to listen to (default is PORT)
ip
    IP address to bind (default is all)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.__init__" class="source">
    <pre><code>def __init__(self, appClass, port=PORT, ip=None, verbose=False):
    '''
    Parameters
    -------------
    appClass
        Class that inherits Client. Note that this is the
        class name and not an instance.
    port
        Port to listen to (default is PORT)
    ip
        IP address to bind (default is all)
    '''
    self.verbose = verbose
    # Instantiate objects of this class; must inherit from Client
    self.appClass = appClass
    self.contextMap = {}
    # The port number
    self.port = port
    if ip is None:
        ip = '127.0.0.1'
    # Create the server object. Must call start() to begin listening.
    super(Server, self).__init__((ip, port), Handler)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.close_request">
    <p>def <span class="ident">close_request</span>(</p><p>self, request)</p>
    </div>
    

    
  
    <div class="desc"><p>Called to clean up an individual request.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.close_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.close_request" class="source">
    <pre><code>def close_request(self, request):
    """Called to clean up an individual request."""
    request.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.fileno">
    <p>def <span class="ident">fileno</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return socket file number.</p>
<p>Interface required by selector.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.fileno', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.fileno" class="source">
    <pre><code>def fileno(self):
    """Return socket file number.
    Interface required by selector.
    """
    return self.socket.fileno()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.finish_request">
    <p>def <span class="ident">finish_request</span>(</p><p>self, request, client_address)</p>
    </div>
    

    
  
    <div class="desc"><p>Finish one request by instantiating RequestHandlerClass.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.finish_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.finish_request" class="source">
    <pre><code>def finish_request(self, request, client_address):
    """Finish one request by instantiating RequestHandlerClass."""
    self.RequestHandlerClass(request, client_address, self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.get_request">
    <p>def <span class="ident">get_request</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the request and client address from the socket.</p>
<p>May be overridden.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.get_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.get_request" class="source">
    <pre><code>def get_request(self):
    """Get the request and client address from the socket.
    May be overridden.
    """
    return self.socket.accept()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.handle_error">
    <p>def <span class="ident">handle_error</span>(</p><p>self, request, client_address)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle an error gracefully.  May be overridden.</p>
<p>The default is to print a traceback and continue.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.handle_error', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.handle_error" class="source">
    <pre><code>def handle_error(self, request, client_address):
    """Handle an error gracefully.  May be overridden.
    The default is to print a traceback and continue.
    """
    print('-'*40, file=sys.stderr)
    print('Exception happened during processing of request from',
        client_address, file=sys.stderr)
    import traceback
    traceback.print_exc()
    print('-'*40, file=sys.stderr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.handle_request">
    <p>def <span class="ident">handle_request</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle one request, possibly blocking.</p>
<p>Respects self.timeout.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.handle_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.handle_request" class="source">
    <pre><code>def handle_request(self):
    """Handle one request, possibly blocking.
    Respects self.timeout.
    """
    # Support people who used socket.settimeout() to escape
    # handle_request before self.timeout was available.
    timeout = self.socket.gettimeout()
    if timeout is None:
        timeout = self.timeout
    elif self.timeout is not None:
        timeout = min(timeout, self.timeout)
    if timeout is not None:
        deadline = time() + timeout
    # Wait until a request arrives or the timeout expires - the loop is
    # necessary to accommodate early wakeups due to EINTR.
    with _ServerSelector() as selector:
        selector.register(self, selectors.EVENT_READ)
        while True:
            ready = selector.select(timeout)
            if ready:
                return self._handle_request_noblock()
            else:
                if timeout is not None:
                    timeout = deadline - time()
                    if timeout < 0:
                        return self.handle_timeout()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.handle_timeout">
    <p>def <span class="ident">handle_timeout</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called if no new request arrives within self.timeout.</p>
<p>Overridden by ForkingMixIn.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.handle_timeout', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.handle_timeout" class="source">
    <pre><code>def handle_timeout(self):
    """Called if no new request arrives within self.timeout.
    Overridden by ForkingMixIn.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.js">
    <p>def <span class="ident">js</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>If you are implementing a single application without a "main"
function, you can call this to retrieve the JS object and set
up for single instance execution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.js', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.js" class="source">
    <pre><code>def js(self):
    '''
    If you are implementing a single application without a "main"
    function, you can call this to retrieve the JS object and set
    up for single instance execution.
    '''
    return self._getContextForPage('SINGLE', True).getJS()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.log_error">
    <p>def <span class="ident">log_error</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.log_error', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.log_error" class="source">
    <pre><code>def log_error(self, format, *args):
    print(format % args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.log_message">
    <p>def <span class="ident">log_message</span>(</p><p>self, format, *args)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.log_message', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.log_message" class="source">
    <pre><code>def log_message(self, format, *args):
    if self.verbose:
        print(format % args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.process_request">
    <p>def <span class="ident">process_request</span>(</p><p>self, request, client_address)</p>
    </div>
    

    
  
    <div class="desc"><p>Start a new thread to process the request.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.process_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.process_request" class="source">
    <pre><code>def process_request(self, request, client_address):
    """Start a new thread to process the request."""
    t = threading.Thread(target = self.process_request_thread,
                         args = (request, client_address))
    t.daemon = self.daemon_threads
    if not t.daemon and self.block_on_close:
        if self._threads is None:
            self._threads = []
        self._threads.append(t)
    t.start()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.process_request_thread">
    <p>def <span class="ident">process_request_thread</span>(</p><p>self, request, client_address)</p>
    </div>
    

    
  
    <div class="desc"><p>Same as in BaseServer but as a thread.</p>
<p>In addition, exception handling is done here.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.process_request_thread', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.process_request_thread" class="source">
    <pre><code>def process_request_thread(self, request, client_address):
    """Same as in BaseServer but as a thread.
    In addition, exception handling is done here.
    """
    try:
        self.finish_request(request, client_address)
    except Exception:
        self.handle_error(request, client_address)
    finally:
        self.shutdown_request(request)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.serve_forever">
    <p>def <span class="ident">serve_forever</span>(</p><p>self, poll_interval=0.5)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle one request at a time until shutdown.</p>
<p>Polls for shutdown every poll_interval seconds. Ignores
self.timeout. If you need to do periodic tasks, do them in
another thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.serve_forever', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.serve_forever" class="source">
    <pre><code>def serve_forever(self, poll_interval=0.5):
    """Handle one request at a time until shutdown.
    Polls for shutdown every poll_interval seconds. Ignores
    self.timeout. If you need to do periodic tasks, do them in
    another thread.
    """
    self.__is_shut_down.clear()
    try:
        # XXX: Consider using another file descriptor or connecting to the
        # socket to wake this up instead of polling. Polling reduces our
        # responsiveness to a shutdown request and wastes cpu at all other
        # times.
        with _ServerSelector() as selector:
            selector.register(self, selectors.EVENT_READ)
            while not self.__shutdown_request:
                ready = selector.select(poll_interval)
                # bpo-35017: shutdown() called during select(), exit immediately.
                if self.__shutdown_request:
                    break
                if ready:
                    self._handle_request_noblock()
                self.service_actions()
    finally:
        self.__shutdown_request = False
        self.__is_shut_down.set()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.server_activate">
    <p>def <span class="ident">server_activate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by constructor to activate the server.</p>
<p>May be overridden.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.server_activate', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.server_activate" class="source">
    <pre><code>def server_activate(self):
    """Called by constructor to activate the server.
    May be overridden.
    """
    self.socket.listen(self.request_queue_size)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.server_bind">
    <p>def <span class="ident">server_bind</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by constructor to bind the socket.</p>
<p>May be overridden.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.server_bind', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.server_bind" class="source">
    <pre><code>def server_bind(self):
    """Called by constructor to bind the socket.
    May be overridden.
    """
    if self.allow_reuse_address:
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.socket.bind(self.server_address)
    self.server_address = self.socket.getsockname()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.server_close">
    <p>def <span class="ident">server_close</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.server_close', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.server_close" class="source">
    <pre><code>def server_close(self):
    super().server_close()
    if self.block_on_close:
        threads = self._threads
        self._threads = None
        if threads:
            for thread in threads:
                thread.join()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.service_actions">
    <p>def <span class="ident">service_actions</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Called by the serve_forever() loop.</p>
<p>May be overridden by a subclass / Mixin to implement any code that
needs to be run during the loop.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.service_actions', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.service_actions" class="source">
    <pre><code>def service_actions(self):
    """Called by the serve_forever() loop.
    May be overridden by a subclass / Mixin to implement any code that
    needs to be run during the loop.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.shutdown">
    <p>def <span class="ident">shutdown</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Stops the serve_forever loop.</p>
<p>Blocks until the loop has finished. This must be called while
serve_forever() is running in another thread, or it will
deadlock.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.shutdown', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.shutdown" class="source">
    <pre><code>def shutdown(self):
    """Stops the serve_forever loop.
    Blocks until the loop has finished. This must be called while
    serve_forever() is running in another thread, or it will
    deadlock.
    """
    self.__shutdown_request = True
    self.__is_shut_down.wait()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.shutdown_request">
    <p>def <span class="ident">shutdown_request</span>(</p><p>self, request)</p>
    </div>
    

    
  
    <div class="desc"><p>Called to shutdown and close an individual request.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.shutdown_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.shutdown_request" class="source">
    <pre><code>def shutdown_request(self, request):
    """Called to shutdown and close an individual request."""
    try:
        #explicitly shutdown.  socket.close() merely releases
        #the socket and waits for GC to perform the actual close.
        request.shutdown(socket.SHUT_WR)
    except OSError:
        pass #some platforms may raise ENOTCONN here
    self.close_request(request)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.start">
    <p>def <span class="ident">start</span>(</p><p>self, wait=True, cookies=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Start listening to the port and processing requests.</p>
<h2>Parameters</h2>
<p>wait
    Start listening and wait for server to terminate. If this
    is false, start server on new thread and continue execution.
cookies
    If True, try to use cookies to keep track of sessions. This
    enables the browser to open multiple windows that all share
    the same Client object. If False, then cookies are disabled
    and each tab will be it's own session.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.start', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.start" class="source">
    <pre><code>def start(self, wait=True, cookies=True):
    '''
    Start listening to the port and processing requests.
    Parameters
    ------------
    wait
        Start listening and wait for server to terminate. If this
        is false, start server on new thread and continue execution.
    cookies
        If True, try to use cookies to keep track of sessions. This
        enables the browser to open multiple windows that all share
        the same Client object. If False, then cookies are disabled
        and each tab will be it's own session.
    '''
    self.useCookies = cookies
    if wait or hasattr(self.appClass, "main"):
        self._runServer()
    else:
        server_thread = threading.Thread(target=self._runServer, daemon=True)
        server_thread.start()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.stop">
    <p>def <span class="ident">stop</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.stop', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.stop" class="source">
    <pre><code>def stop(self):
    # self._BaseServer__shutdown_request = True
    self._runmode = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="jyserver.Server.verify_request">
    <p>def <span class="ident">verify_request</span>(</p><p>self, request, client_address)</p>
    </div>
    

    
  
    <div class="desc"><p>Verify the request.  May be overridden.</p>
<p>Return True if we should proceed with this request.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.Server.verify_request', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.Server.verify_request" class="source">
    <pre><code>def verify_request(self, request, client_address):
    """Verify the request.  May be overridden.
    Return True if we should proceed with this request.
    """
    return True
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="jyserver.Server.appClass" class="name">var <span class="ident">appClass</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.contextMap" class="name">var <span class="ident">contextMap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.port" class="name">var <span class="ident">port</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="jyserver.Server.verbose" class="name">var <span class="ident">verbose</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="jyserver.XJSstate" class="name">class <span class="ident">XJSstate</span></p>
      
  
    <div class="desc"><p>JState keeps track of the Javascript state on the browser.</p>
<h2>Attributes</h2>
<p>_tasks
    A queue of pending tasks that must be performed on the
    browser.
_fxn
    Map to keep track of callables that the browser's 
    Javascript is allowed to call.
_queries
    When python requests a statement to be evaluated, a
    unique query id is assigned. Then a Queue is created
    to wait for reasults. This maps ids to Queues.
_error
    If tasks have errors, the last Exception object is
    stored here. Value is None if there are no errors.
_server
    The server tied to this state</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.XJSstate', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.XJSstate" class="source">
    <pre><code>class XJSstate:
    '''
    JState keeps track of the Javascript state on the browser.

    Attributes
    ------------
    _tasks
        A queue of pending tasks that must be performed on the
        browser.
    _fxn
        Map to keep track of callables that the browser's 
        Javascript is allowed to call.
    _queries
        When python requests a statement to be evaluated, a
        unique query id is assigned. Then a Queue is created
        to wait for reasults. This maps ids to Queues.
    _error
        If tasks have errors, the last Exception object is
        stored here. Value is None if there are no errors.
    _server
        The server tied to this state
    '''

    def __init__(self, server):
        self._tasks = queue.Queue()
        self._fxn = {}
        self._queries = {}
        self._error = None
        self._server = server
        self._lock = threading.Lock()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#jyserver.XJSstate">XJSstate</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="jyserver.XJSstate.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, server)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-jyserver.XJSstate.__init__', this);">Show source &equiv;</a></p>
  <div id="source-jyserver.XJSstate.__init__" class="source">
    <pre><code>def __init__(self, server):
    self._tasks = queue.Queue()
    self._fxn = {}
    self._queries = {}
    self._error = None
    self._server = server
    self._lock = threading.Lock()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
